<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Escape</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0d0d0d;
            color: #f0f0f0;
            font-family: 'Vazirmatn', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            text-align: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0a0a0a;
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 90vh;
            aspect-ratio: 4/3;
        }

        canvas {
            display: block;
            background-color: #0d0d0d;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .ui-panel {
            position: absolute;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 80%;
            max-width: 400px;
        }

        .ui-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .ui-panel.half-visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
            max-width: 600px; /* Wider for shop and missions */
        }

        .ui-panel h1, .ui-panel h2 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 15px #fff;
        }

        .ui-panel p {
            font-size: 1.1rem;
            margin: 0 0 20px 0;
            line-height: 1.6;
            color: #ccc;
        }

        .button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            border: none;
            border-radius: 10px;
            background: linear-gradient(145deg, #1f1f1f, #2a2a2a);
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3), -5px -5px 15px rgba(255,255,255,0.05);
            transition: all 0.2s ease;
            user-select: none;
        }

        .button:hover {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            transform: translateY(-2px);
            box-shadow: 8px 8px 20px rgba(0,0,0,0.4), -8px -8px 20px rgba(255,255,255,0.08);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
        }

        .upgrade-card, .shop-item, .mission-item {
            background: rgba(30, 30, 30, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
            text-align: right;
            position: relative;
        }
        
        .upgrade-card h3, .shop-item h3, .mission-item h3 {
            margin: 0 0 5px 0;
            color: #f0f0f0;
            font-size: 1.2rem;
        }

        .upgrade-card p, .shop-item p, .mission-item p {
            margin: 0;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .shop-item:hover, .upgrade-card:hover {
            border-color: #4a4a4a;
        }
        
        .shop-item .price, .mission-item .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        #hud-container {
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            width: 100%;
            position: absolute;
            top: 20px;
            left: 0;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            width: 100%;
            max-width: 800px;
            padding: 0 20px;
        }

        #hud > div {
            background: rgba(10, 10, 10, 0.5);
            backdrop-filter: blur(5px);
            padding: 8px 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #hud-left, #hud-right {
            display: flex;
            gap: 10px;
        }
        
        #hud-center {
            display: flex;
            gap: 10px;
        }
        
        #wave-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #wave-timer {
            font-size: 1.2rem;
            font-weight: bold;
        }

        #shield-bar {
            width: 100px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-right: 5px;
        }

        #shield-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffff);
            transition: width 0.1s linear;
        }

        #boss-health-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid #ff0000;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 50;
        }

        #boss-health-progress {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6347);
        }

        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #ff0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #audio-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px; /* Moved to the left */
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            color: #fff;
            text-shadow: 0 0 5px #fff;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.9);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        #message-box p {
            margin: 0 0 20px 0;
            color: #fff;
        }

        #message-box button {
            background: #2a2a2a;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #ffffff;
            animation: spin 1s ease infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        #shootBtn {
          position: absolute;
          bottom: 20px;
          right: 20px;
          padding: 10px 20px;
          font-size: 18px;
          cursor: pointer;
          z-index: 100;
          background: linear-gradient(45deg, #00aaff, #00ffff);
          color: #1a1a1a;
          border: none;
          border-radius: 10px;
          box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
          transition: all 0.2s ease;
          font-weight: bold;
          display: none; /* Default hidden for desktop */
        }
        
        #shootBtn:hover {
            transform: scale(1.1);
        }
        
        #shootBtn:active {
            transform: scale(0.95);
        }
        
        /* Responsive CSS for smaller screens */
        @media (max-width: 600px) {
            #game-container {
                max-width: 98vw;
                max-height: 98vh;
            }
            .ui-panel {
                width: 90%;
                max-width: 300px;
            }
            .ui-panel h1, .ui-panel h2 {
                font-size: 1.8rem;
            }
            .ui-panel p {
                font-size: 1rem;
            }
            .button {
                font-size: 1rem;
                padding: 12px;
                margin: 10px 0;
            }
            #hud {
                top: 10px;
                left: 10px;
                right: 10px;
                font-size: 0.8rem;
            }
            #hud > div {
                padding: 6px 10px;
            }
            #shield-bar {
                width: 70px;
            }
            #combo-display {
                font-size: 2rem;
            }
            
            #audio-toggle {
                bottom: 20px;
                left: 20px;
            }

            /* Show shoot button on mobile and position it */
            #shootBtn {
                display: block; /* Show the button on mobile */
                bottom: 20px;
                right: 20px;
                transform: translateX(0);
                font-size: 1rem;
                padding: 10px 15px;
            }
        }
        
        .mission-item.completed {
            background: rgba(0, 100, 0, 0.9);
            border-color: #00ff00;
            color: #fff;
        }

        #missions-menu, #shop-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #missions-list, #shop-items {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            width: 100%;
        }

        @media (min-width: 600px) {
            #missions-list, #shop-items {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
        }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <button id="shootBtn">شلیک</button>

        <div id="main-menu" class="ui-panel visible">
            <h1>Shadow Escape</h1>
            <p>فرار از سایه‌ها، جمع‌آوری نور</p>
            <button class="button" id="play-button">شروع بازی</button>
            <button class="button" id="shop-button">فروشگاه</button>
            <button class="button" id="tutorial-button">آموزش</button>
            <button class="button" id="settings-button">تنظیمات</button>
            <p style="margin-top: 20px;">بالاترین امتیاز: <span id="highscore-display">0</span></p>
        </div>

        <div id="tutorial-menu" class="ui-panel">
            <h1>آموزش</h1>
            <p id="tutorial-text">
                به عنوان یک نقطه‌ی نور، از سایه‌ها فرار کنید و زنده بمانید.<br>
                برای حرکت از ماوس، لمس یا کلیدهای WASD/جهت‌نما استفاده کنید.<br>
                نزدیک شدن به دشمنان بدون برخورد، کامبو و امتیاز شما را افزایش می‌دهد.
                <br>
                برای شلیک به سمت نشانگر ماوس یا لمس، دکمه Space را فشار دهید.
            </p>
            <button class="button" id="read-tutorial-button">✨ توضیحات صوتی</button>
            <button class="button" id="back-to-main">بازگشت</button>
        </div>

        <div id="game-over-menu" class="ui-panel">
            <h1>بازی تمام شد!</h1>
            <p>امتیاز شما: <span id="final-score">0</span></p>
            <p>موج نهایی: <span id="final-wave">0</span></p>
            <button class="button" id="retry-button">تلاش مجدد</button>
            <button class="button" id="back-to-main-from-gameover">بازگشت به منو</button>
        </div>

        <div id="upgrade-menu" class="ui-panel">
            <h2>ارتقاءها</h2>
            <p>انتخاب یک ارتقاء برای موج بعدی:</p>
            <div id="upgrade-options"></div>
            <button class="button" id="magical-upgrade-button">✨ ارتقاء جادویی</button>
            <button class="button" id="show-missions-button">ماموریت‌ها</button>
        </div>
        
        <div id="missions-menu" class="ui-panel half-visible">
            <h2>ماموریت‌ها</h2>
            <p>جوایز خود را با تکمیل این ماموریت‌ها دریافت کنید.</p>
            <div id="missions-list"></div>
            <button class="button" id="back-from-missions">بازگشت</button>
        </div>

        <div id="shop-menu" class="ui-panel half-visible">
            <h2>فروشگاه</h2>
            <p>امتیاز خود را خرج کنید تا ارتقاءهای دائمی بخرید.</p>
            <div id="shop-items"></div>
            <p>امتیاز فعلی: <span id="shop-score">0</span></p>
            <button class="button" id="back-to-main-from-shop">بازگشت</button>
        </div>

        <div id="settings-menu" class="ui-panel">
            <h2>تنظیمات</h2>
            <div style="margin-bottom: 10px;">
                <label for="music-volume">موزیک:</label>
                <input type="range" id="music-volume" name="music-volume" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div style="margin-bottom: 20px;">
                <label for="sfx-volume">افکت‌های صوتی:</label>
                <input type="range" id="sfx-volume" name="sfx-volume" min="0" max="1" step="0.05" value="0.7">
            </div>
            <p>
                <label for="mouse-sensitivity">حساسیت ماوس:</label>
                <input type="range" id="mouse-sensitivity" name="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
            </p>
            <button class="button" id="back-to-main-from-settings">بازگشت</button>
        </div>

        <div id="hud-container">
            <div id="hud">
                <div id="hud-left">
                    <div>امتیاز: <span id="score">0</span></div>
                    <div>موج: <span id="wave">1</span></div>
                </div>
                <div id="hud-center">
                    <div id="wave-info">
                        <div>زمان باقیمانده:</div>
                        <div id="wave-timer"></div>
                    </div>
                </div>
                <div id="hud-right">
                    <div style="display: flex; align-items: center;">سپر: <div id="shield-bar"><div id="shield-progress"></div></div><span id="shield-time">0</span></div>
                    <div>کامبو: <span id="combo-count">0</span></div>
                </div>
            </div>
        </div>
        
        <div id="boss-health-bar">
            <div id="boss-health-progress"></div>
        </div>

        <div id="combo-display"></div>

        <div id="audio-toggle">🔊</div>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
    </div>

    <div id="message-box">
        <p id="message-text"></p>
        <button id="message-close-button">باشه</button>
    </div>

    <script>
        // Start of the main game script

        // =================================================================
        // Modules and Configuration
        // =================================================================

        const config = {
            canvas: {
                width: 800,
                height: 600,
            },
            player: {
                radius: 14,
                baseSpeed: 260,
                maxSpeed: 400,
                glowColor: '#fff',
                shieldTime: 2,
                comboBonusMultiplier: 0.15,
                comboNearMissDistance: 40,
                projectileSpeed: 400,
                fireRate: 0.3,
                damage: 20,
            },
            enemies: {
                baseRadius: 16,
                baseSpeed: 120,
                spawnDistance: 300,
                spawnRatePerWave: 1.8,
            },
            items: {
                spawnRate: 0.002,
                rarity: {
                    shield: 0.35,
                    freeze: 0.15,
                    crystal: 0.4,
                    slow_mo: 0.05,
                    double_score: 0.05,
                },
            },
            waves: {
                minEnemies: 5,
                baseEnemyCount: 7,
                linearGrowth: 4,
                wavePauseDuration: 3,
                bossWaveInterval: 5,
                waveDuration: 30,
                waveDurationGrowth: 5,
            },
            upgrades: {
                optionCount: 3,
                options: [
                    { name: 'سرعت', effect: (player) => player.speed *= 1.15, description: 'افزایش سرعت حرکت (+15%)' },
                    { name: 'سپر', effect: (player) => { player.shieldTime += 4; player.maxShieldTime += 4; }, description: 'افزایش زمان سپر (+4s)' },
                    { name: 'امتیاز', effect: (player) => gameManager.score += 150, description: 'امتیاز فوری (+150)' },
                    { name: 'کامبو', effect: (player) => player.comboMultiplier += 0.3, description: 'افزایش ضریب کامبو' },
                    { name: 'نرخ شلیک', effect: (player) => player.fireRate *= 1.2, description: 'افزایش نرخ شلیک' },
                ],
                offlineUpgrades: [
                    { name: 'سپر ویژه', type: 'shield', description: 'افزایش زمان سپر (+8s)' },
                    { name: 'انرژی نور', type: 'score', description: 'امتیاز فوری (+400)' },
                ]
            },
            shop: [
                { name: 'افزایش سرعت', price: 200, id: 'speed_up', effect: (player) => player.baseSpeed *= 1.1 },
                { name: 'سپر بیشتر', price: 150, id: 'shield_up', effect: (player) => player.maxShieldTime += 1 },
                { name: 'افزایش آسیب', price: 300, id: 'damage_up', effect: (player) => player.damage *= 1.2 },
            ],
            missions: [
                { id: 'kill10chasers', type: 'kill', enemy: 'chaser', count: 10, reward: 100, completed: false, description: 'کشتن ۱۰ دشمن تعقیب‌کننده' },
                { id: 'get500score', type: 'score', amount: 500, reward: 50, completed: false, description: 'رسیدن به امتیاز ۵۰۰' },
                { id: 'kill50enemies', type: 'kill', enemy: 'any', count: 50, reward: 150, completed: false, description: 'کشتن ۵۰ دشمن' },
            ],
            projectiles: {
                tripleShotAngle: 15, // degrees
            },
            particles: {
                playerGlowDensity: 5,
                itemGlowDensity: 3,
                maxParticles: 400,
            },
        audio: { ambienceVolume: 0.5, sfxVolume: 0.7, sfxUrls: { pickup: 'key-176034.mp3', hit: 'Metal Hit.mp3', freeze: 'coldsnap.wav', slow_mo: 'coldsnap.wav', ambience: '544416__zhr__background-music.mp3', player_shoot: 'SHOOT007.mp3', boss_hit: 'sfx_hurt.ogg', boss_explosion: 'Battle in the winter.mp3', boss_spawn: 'theircoming3.ogg', } } };

        // Global variables, consolidated to avoid redeclaration errors
        let screenShakeX = 0;
        let screenShakeY = 0;
        const SCREEN_SHAKE_DURATION = 0.2;
        let screenShakeTime = 0;
        let musicVolume = parseFloat(localStorage.getItem('musicVolume')) || config.audio.ambienceVolume;
        let sfxVolume = parseFloat(localStorage.getItem('sfxVolume')) || config.audio.sfxVolume;
        let mouseSensitivity = parseFloat(localStorage.getItem('mouseSensitivity')) || 1.0;
        let isSlowMotion = false;
        let slowMotionTimer = 0;
        let scoreMultiplier = 1;
        let persistentUpgrades = JSON.parse(localStorage.getItem('persistentUpgrades')) || {};
        let boss = null;
        let playerProjectiles = [];
        let playerLastShotTime = 0;
        const scoreThreshold = 1500;
        let waveTimer = 0;
        let mousePos = { x: 0, y: 0 };
        let highscore = localStorage.getItem('shadow_escape_highscore') || 0;
        let enemySpawnTimer = 0;
        let currentWaveDuration = 0;
        let missions = JSON.parse(localStorage.getItem('missions')) || config.missions;
        let shopItems = JSON.parse(localStorage.getItem('shopItems')) || config.shop;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            config.canvas.width = canvas.width;
            config.canvas.height = canvas.height;
            if (player) {
                player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
            }
        }
        window.addEventListener('resize', resizeCanvas);

        const mainContainer = document.getElementById('game-container');
        const mainMenu = document.getElementById('main-menu');
        const tutorialMenu = document.getElementById('tutorial-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const upgradeMenu = document.getElementById('upgrade-menu');
        const missionsMenu = document.getElementById('missions-menu');
        const shopMenu = document.getElementById('shop-menu');
        const settingsMenu = document.getElementById('settings-menu');
        const hud = document.getElementById('hud');
        const comboDisplay = document.getElementById('combo-display');
        const audioToggle = document.getElementById('audio-toggle');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const loadingOverlay = document.getElementById('loading-overlay');
        const shieldProgressBar = document.getElementById('shield-progress');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthProgress = document.getElementById('boss-health-progress');
        const waveTimerDisplay = document.getElementById('wave-timer');
        
        // D-pad button elements for mobile
        const shootBtn = document.getElementById('shootBtn');

        let lastTime = 0;
        let gameActive = false;
        let isPaused = false;
        let player, enemies, items, particles, projectiles;
        let audioManager;
        let obstacles = []; // آرایه برای نگهداری موانع

        // Ensure mousePos is initialized properly based on new canvas size
        window.addEventListener('load', () => {
            resizeCanvas();
            mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        });

        const inputManager = {
            keys: {},
            lastMoveTime: 0,
            init() {
                window.addEventListener('keydown', (e) => {
                    // Prevent default behavior for spacebar and other movement keys
                    if (e.code === 'Space' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 's' || e.key.toLowerCase() === 'd' ||
                        e.key.toLowerCase() === 'arrowup' || e.key.toLowerCase() === 'arrowleft' || e.key.toLowerCase() === 'arrowdown' || e.key.toLowerCase() === 'arrowright') {
                        e.preventDefault();
                    }
                    
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.code === 'Space') {
                        if (gameActive && player) {
                            player.isShooting = true;
                        }
                    }
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    if (e.code === 'Space') {
                        if (player) player.isShooting = false;
                    }
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (gameActive) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.clientX - rect.left) * scaleX;
                        mousePos.y = (e.clientY - rect.top) * scaleY;
                    }
                });
                canvas.addEventListener('touchmove', (e) => {
                    if (e.cancelable) e.preventDefault();
                    if (gameActive && e.touches.length > 0) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.touches[0].clientX - rect.left) * scaleX;
                        mousePos.y = (e.touches[0].clientY - rect.top) * scaleY;
                    }
                }, { passive: false });
                canvas.addEventListener('mousedown', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                });
                canvas.addEventListener('mouseup', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
                canvas.addEventListener('touchstart', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
            },
            getMovementVector() {
                const vector = { x: 0, y: 0 };
                const keyboardActive = this.keys['w'] || this.keys['a'] || this.keys['s'] || this.keys['d'] ||
                                      this.keys['arrowup'] || this.keys['arrowleft'] || this.keys['arrowdown'] || this.keys['arrowright'];

                if (keyboardActive) {
                    if (this.keys['w'] || this.keys['arrowup']) vector.y = -1;
                    if (this.keys['s'] || this.keys['arrowdown']) vector.y = 1;
                    if (this.keys['a'] || this.keys['arrowleft']) vector.x = -1;
                    if (this.keys['d'] || this.keys['arrowright']) vector.x = 1;

                    const len = Math.hypot(vector.x, vector.y);
                    if (len > 0) { vector.x /= len; vector.y /= len; }
                } else {
                    if (player) {
                        const dx = mousePos.x - player.x;
                        const dy = mousePos.y - player.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 1) {
                            vector.x = (dx / dist) * mouseSensitivity;
                            vector.y = (dy / dist) * mouseSensitivity;
                            vector.dist = dist;
                        }
                    }
                }

                return vector;
            }
        };

        // =================================================================
        // Audio Manager
        // =================================================================
        class AudioManager {
            constructor() {
                this.isInitialized = false;
                this.isMuted = false;
                this.ambience = null;
                this.sfx = {};
                this.sfxUrls = config.audio.sfxUrls;
            }

            init() {
                if (this.isInitialized) return;
                this.isInitialized = true;

                this.ambience = new Audio();
                this.ambience.loop = true;
                this.ambience.volume = musicVolume;
                this.ambience.src = this.sfxUrls.ambience;
                this.ambience.onerror = () => console.log('Failed to load ambience audio.');

                for (const key in this.sfxUrls) {
                    if (key !== 'ambience') {
                        this.sfx[key] = new Audio(this.sfxUrls[key]);
                        this.sfx[key].volume = sfxVolume;
                        this.sfx[key].onerror = () => console.log(`Failed to load SFX: ${key}`);
                    }
                }
            }

            updateVolumes(newMusicVolume, newSfxVolume) {
                musicVolume = newMusicVolume;
                sfxVolume = newSfxVolume;
                if (this.ambience) {
                    this.ambience.volume = musicVolume;
                }
                for (const key in this.sfx) {
                    this.sfx[key].volume = sfxVolume;
                }
                localStorage.setItem('musicVolume', musicVolume);
                localStorage.setItem('sfxVolume', sfxVolume);
            }

            playAmbience() {
                if (this.ambience && !this.isMuted) {
                    this.ambience.play().catch(e => console.log('Ambience playback blocked:', e));
                }
            }
            pauseAmbience() {
                if (this.ambience) {
                    this.ambience.pause();
                }
            }
            playSfx(name) {
                if (!this.isInitialized || this.isMuted) return;
                const sfx = this.sfx[name];
                if (sfx) {
                    const clonedSfx = sfx.cloneNode();
                    clonedSfx.volume = sfx.volume;
                    clonedSfx.play().catch(e => console.log('SFX playback blocked:', e));
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.isMuted) {
                    this.pauseAmbience();
                    audioToggle.textContent = '🔇';
                } else {
                    this.playAmbience();
                    audioToggle.textContent = '🔊';
                }
            }
        }

        const particlePool = [];
        let particlePoolIndex = 0;
        function getParticle(x, y, velocity, color, radius, life) {
            if (particlePool.length < config.particles.maxParticles) {
                const newParticle = new Particle(x, y, velocity, color, radius, life);
                particlePool.push(newParticle);
                return newParticle;
            } else {
                const particle = particlePool[particlePoolIndex];
                particle.reset(x, y, velocity, color, radius, life);
                particlePoolIndex = (particlePoolIndex + 1) % config.particles.maxParticles;
                return particle;
            }
        }

        // =================================================================
        // Game Objects (Player, Enemy, Item, Particle)
        // =================================================================
        class PlayerProjectile {
            constructor(x, y, direction, damage) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = config.player.projectileSpeed;
                this.radius = 3;
                this.color = '#fff';
                this.isDead = false;
                this.damage = damage;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        class TripleShotProjectile extends PlayerProjectile {
             constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#ff0';
                this.radius = 4;
            }
        }
        
        class LaserProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.length = 200;
                this.width = 5;
                this.color = '#0f0';
                this.isDead = false;
                this.hitEnemies = new Set();
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < -this.length || this.x > canvas.width + this.length || this.y < -this.length || this.y > canvas.height + this.length) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const angle = Math.atan2(this.direction.y, this.direction.x);
                ctx.rotate(angle);
                
                const gradient = ctx.createLinearGradient(0, -this.width/2, this.length, this.width/2);
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, -this.width/2, this.length, this.width);
                ctx.restore();
            }
        }
        
        class BombProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#f00';
                this.radius = 8;
                this.isExploded = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 100;
                this.explosionDuration = 0.3;
                this.explosionTimer = 0;
            }
            update(dt) {
                if (this.isExploded) {
                    this.explosionTimer += dt;
                    this.explosionRadius = (this.explosionTimer / this.explosionDuration) * this.maxExplosionRadius;
                    if (this.explosionTimer >= this.explosionDuration) {
                        this.isDead = true;
                    }
                } else {
                    this.x += this.direction.x * this.speed * dt;
                    this.y += this.direction.y * this.speed * dt;
                    // check collision with enemies to trigger explosion
                    for (const enemy of enemies) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < this.radius + enemy.radius) {
                            this.isExploded = true;
                            // Trigger explosion on hit
                            break;
                        }
                    }
                }
            }
            draw(ctx) {
                if (this.isExploded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.explosionRadius, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.explosionRadius);
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else {
                    super.draw(ctx);
                }
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = config.player.radius;
                this.speed = config.player.baseSpeed;
                this.shieldTime = config.player.shieldTime;
                this.isInvincible = false;
                this.combo = 0;
                this.comboBonus = 0;
                this.comboMultiplier = 1;
                this.targetSpeed = this.speed;
                this.deathTimer = 0;
                this.originalSpeed = this.speed;
                this.shieldEffectTimer = 0;
                this.isShieldActive = false;
                this.maxShieldTime = config.player.shieldTime;
                this.isShooting = false;
                this.shootCooldown = 0;
                this.projectileType = 'basic'; // 'basic', 'triple', 'laser', 'bomb'
                this.damage = config.player.damage;

                // Apply persistent upgrades
                this.speed = config.player.baseSpeed * (persistentUpgrades.speed || 1);
                this.maxShieldTime = config.player.shieldTime * (persistentUpgrades.shield || 1);
                this.damage = config.player.damage * (persistentUpgrades.damage || 1);
                this.shieldTime = this.maxShieldTime;
            }
            
            // Function to upgrade projectile type
            setProjectileType(type) {
                this.projectileType = type;
            }

            shoot() {
                if (this.shootCooldown <= 0) {
                    const dx = mousePos.x - this.x;
                    const dy = mousePos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const direction = {x: dx/dist, y: dy/dist};
                    
                    if (this.projectileType === 'basic') {
                        playerProjectiles.push(new PlayerProjectile(this.x, this.y, direction, this.damage));
                        this.shootCooldown = 1 / config.player.fireRate;
                    } else if (this.projectileType === 'triple') {
                        const baseAngle = Math.atan2(direction.y, direction.x);
                        const angle1 = baseAngle - (config.projectiles.tripleShotAngle * Math.PI / 180);
                        const angle2 = baseAngle;
                        const angle3 = baseAngle + (config.projectiles.tripleShotAngle * Math.PI / 180);
                        
                        playerProjectiles.push(new TripleShotProjectile(this.x, this.y, {x: Math.cos(angle1), y: Math.sin(angle1)}, this.damage));
                        playerProjectiles.push(new TripleShotProjectile(this.x, this.y, {x: Math.cos(angle2), y: Math.sin(angle2)}, this.damage));
                        playerProjectiles.push(new TripleShotProjectile(this.x, this.y, {x: Math.cos(angle3), y: Math.sin(angle3)}, this.damage));
                        this.shootCooldown = 1 / (config.player.fireRate * 0.7); // Slower fire rate for triple shot
                    } else if (this.projectileType === 'laser') {
                        playerProjectiles.push(new LaserProjectile(this.x, this.y, direction, this.damage));
                        this.shootCooldown = 1 / (config.player.fireRate * 0.5);
                    } else if (this.projectileType === 'bomb') {
                        playerProjectiles.push(new BombProjectile(this.x, this.y, direction, this.damage * 2));
                        this.shootCooldown = 1 / (config.player.fireRate * 0.3);
                    }
                    
                    if (audioManager) audioManager.playSfx('player_shoot');
                }
            }

            update(dt, inputVector) {
                this.shootCooldown -= dt;
                if (this.isShooting && this.shootCooldown <= 0) {
                    this.shoot();
                }

                this.targetSpeed = this.speed;
                
                const previousShieldState = this.isShieldActive;
                this.isShieldActive = this.shieldTime > 0;
                if (this.isShieldActive) {
                    this.shieldTime -= dt;
                    if (this.shieldTime < 0) this.shieldTime = 0;
                    this.shieldEffectTimer += dt;
                    if (this.shieldEffectTimer > 0.1) {
                        for (let i = 0; i < 3; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const dist = this.radius * 2;
                            particles.push(getParticle(
                                this.x + Math.cos(ang) * dist,
                                this.y + Math.sin(ang) * dist,
                                { x: Math.cos(ang) * 0.5, y: Math.sin(ang) * 0.5 },
                                '#00ffff',
                                Math.random() * 2 + 1,
                                0.5
                            ));
                        }
                        this.shieldEffectTimer = 0;
                    }
                }

                const progress = this.maxShieldTime > 0 ? (this.shieldTime / this.maxShieldTime) * 100 : 0;
                shieldProgressBar.style.width = `${progress}%`;

                if ((!inputVector) || (inputVector.x === 0 && inputVector.y === 0)) {
                    this.targetSpeed = 0;
                } else {
                    if (inputVector.dist !== undefined) {
                        const maxMove = Math.min(this.speed * dt, inputVector.dist);
                        this.x += inputVector.x * maxMove;
                        this.y += inputVector.y * maxMove;
                    } else {
                        this.x += inputVector.x * this.speed * dt;
                        this.y += inputVector.y * this.speed * dt;
                    }
                }

                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                if (particles.length < config.particles.maxParticles) {
                    const spawnCount = Math.max(1, Math.round(config.particles.playerGlowDensity / 2));
                    for (let i = 0; i < spawnCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * this.radius * 0.5;
                        particles.push(getParticle(
                            this.x + Math.cos(angle) * r,
                            this.y + Math.sin(angle) * r,
                            { x: Math.cos(angle), y: Math.sin(angle) },
                            '#fff',
                            Math.random() * 2 + 1,
                            0.5
                        ));
                    }
                }
            }

            draw(ctx) {
                // Drawing the player's core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = config.player.glowColor;
                ctx.fill();

                // Drawing the player's glow
                const gradient = ctx.createRadialGradient(this.x, this.y, this.radius, this.x, this.y, this.radius * 2);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${this.shieldTime > 0 ? 0.3 : 0.2})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); // Corrected: Added beginPath before the second arc
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                if (this.shieldTime > 0) {
                    const shieldGradient = ctx.createRadialGradient(this.x, this.y, this.radius * 1.5, this.x, this.y, this.radius * 1.8);
                    shieldGradient.addColorStop(0, 'rgba(0, 200, 255, 0.5)');
                    shieldGradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Projectile {
            constructor(x, y, direction, speed) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = speed;
                this.radius = 5;
                this.color = '#ff0000';
                this.isDead = false;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = config.enemies.baseRadius;
                this.speed = config.enemies.baseSpeed;
                this.type = type;
                this.color = '#333';
                this.glowColor = '#000';
                this.isFrozen = false;
                this.isFading = false;
                this.shifterTimer = 0;
                this.teleportTimer = Math.random() * 3 + 2;
                this.direction = {x: 0, y: 0};
                this.shooterTimer = 0;
                this.isBoss = (type === 'boss');
                this.health = 1;
                this.maxHealth = 1;
                this.damageReduction = 0; // for armored enemies

                switch (type) {
                    case 'armored':
                        this.health = 50;
                        this.maxHealth = 50;
                        this.color = '#555';
                        this.damageReduction = 0.8;
                        break;
                    case 'teleporter':
                        this.health = 15;
                        this.maxHealth = 15;
                        this.speed = 100;
                        this.color = '#8a2be2';
                        this.glowColor = '#8a2be2';
                        break;
                    case 'pattern_shooter':
                        this.health = 20;
                        this.maxHealth = 20;
                        this.color = '#f00';
                        this.shooterTimer = 2;
                        this.patternShotTimer = 0;
                        this.currentPattern = 'spiral';
                        break;
                    case 'wanderer':
                    case 'shifter':
                        const ang = Math.random() * Math.PI * 2;
                        this.direction = { x: Math.cos(ang), y: Math.sin(ang) };
                        break;
                    default:
                        this.health = 10;
                        this.maxHealth = 10;
                        break;
                }
            }

            update(dt) {
                if (this.isFrozen) return;
                if (!player) return;

                switch (this.type) {
                    case 'chaser':
                    case 'armored':
                    case 'splinterer':
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 0) {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                        }
                        break;
                    case 'wanderer':
                        if (Math.random() < 0.01) {
                            this.direction = {
                                x: Math.random() * 2 - 1,
                                y: Math.random() * 2 - 1
                            };
                            const length = Math.hypot(this.direction.x, this.direction.y);
                            if (length > 0) {
                                this.direction.x /= length;
                                this.direction.y /= length;
                            }
                        }
                        this.x += this.direction.x * this.speed * dt;
                        this.y += this.direction.y * this.speed * dt;
                        break;
                    case 'shifter':
                        this.shifterTimer -= dt;
                        if (this.shifterTimer <= 0) {
                            if (this.isFading) {
                                this.isFading = false;
                                this.shifterTimer = Math.random() * 3 + 2;
                            } else {
                                this.isFading = true;
                                this.shifterTimer = Math.random() * 1.5 + 0.5;
                                this.direction = {
                                    x: Math.random() * 2 - 1,
                                    y: Math.random() * 2 - 1
                                };
                                const length = Math.hypot(this.direction.x, this.direction.y);
                                if (length > 0) {
                                    this.direction.x /= length;
                                    this.direction.y /= length;
                                }
                            }
                        }
                        if (!this.isFading) {
                            this.x += this.direction.x * this.speed * dt;
                            this.y += this.direction.y * this.speed * dt;
                        }
                        break;
                    case 'bomber':
                        const bdx = player.x - this.x;
                        const bdy = player.y - this.y;
                        const bdist = Math.hypot(bdx, bdy);
                        if (bdist > 100) {
                            this.x += (bdx / bdist) * this.speed * dt;
                            this.y += (bdy / bdist) * this.speed * dt;
                        }
                        break;
                    case 'shooter':
                        this.shooterTimer -= dt;
                        if (this.shooterTimer <= 0) {
                            this.shooterTimer = Math.random() * 2 + 1;
                            const sDx = player.x - this.x;
                            const sDy = player.y - this.y;
                            const sDist = Math.hypot(sDx, sDy);
                            if (sDist > 0) {
                                projectiles.push(new Projectile(this.x, this.y, {x: sDx / sDist, y: sDy / sDist}, 200));
                            }
                        }
                        break;
                    case 'teleporter':
                        this.teleportTimer -= dt;
                        if (this.teleportTimer <= 0) {
                            // Particle effect before teleport
                            for(let i=0; i<20; i++) {
                                particles.push(getParticle(this.x, this.y, {x: Math.random()*2-1, y: Math.random()*2-1}, '#8a2be2', Math.random()*3+1, 0.5));
                            }
                            this.x = Math.random() * canvas.width;
                            this.y = Math.random() * canvas.height;
                            // Particle effect after teleport
                            for(let i=0; i<20; i++) {
                                particles.push(getParticle(this.x, this.y, {x: Math.random()*2-1, y: Math.random()*2-1}, '#8a2be2', Math.random()*3+1, 0.5));
                            }
                            this.teleportTimer = Math.random() * 3 + 2;
                        }
                        break;
                    case 'pattern_shooter':
                        this.shooterTimer -= dt;
                        if (this.shooterTimer <= 0) {
                            if (this.currentPattern === 'spiral') {
                                this.patternShotTimer = 0;
                                this.currentPattern = 'circle';
                            } else {
                                this.patternShotTimer = 0;
                                this.currentPattern = 'spiral';
                            }
                            this.shooterTimer = 3;
                        }
                        this.patternShotTimer += dt;
                        if (this.currentPattern === 'spiral') {
                             const angle = this.patternShotTimer * 10;
                             if(Math.sin(angle) > 0.95){
                                 projectiles.push(new Projectile(this.x, this.y, {x: Math.cos(angle), y: Math.sin(angle)}, 200));
                             }
                        } else if (this.currentPattern === 'circle') {
                             if(this.patternShotTimer < 0.1) {
                                 for (let i = 0; i < 8; i++) {
                                     const angle = (i / 8) * Math.PI * 2;
                                     projectiles.push(new Projectile(this.x, this.y, {x: Math.cos(angle), y: Math.sin(angle)}, 250));
                                 }
                             }
                        }
                        break;
                    case 'boss':
                        this.updateBoss(dt);
                        break;
                }
            }

            updateBoss(dt) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (this.health > this.maxHealth * 0.66) { // Phase 1
                    this.speed = 80;
                    this.radius = 40;
                    if (this.shooterTimer <= 0) {
                        this.shooterTimer = 2;
                        if (dist > 0) {
                            projectiles.push(new Projectile(this.x, this.y, {x: dx/dist, y: dy/dist}, 250));
                        }
                    }
                    if (dist > 150) {
                        this.x += (dx/dist) * this.speed * dt;
                        this.y += (dy/dist) * this.speed * dt;
                    }
                } else if (this.health > this.maxHealth * 0.33) { // Phase 2
                    this.speed = 100;
                    this.radius = 50;
                    if (this.shooterTimer <= 0) {
                        this.shooterTimer = 1;
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            projectiles.push(new Projectile(this.x, this.y, {x: Math.cos(angle), y: Math.sin(angle)}, 250));
                        }
                        if (Math.random() < 0.3) {
                            enemies.push(new Enemy(this.x + 50, this.y + 50, 'chaser'));
                        }
                    }
                    this.x += (dx/dist) * this.speed * dt;
                    this.y += (dy/dist) * this.speed * dt;
                } else { // Phase 3
                    this.speed = 150;
                    this.radius = 60;
                    if (this.shooterTimer <= 0) {
                        this.shooterTimer = 0.5;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            projectiles.push(new Projectile(this.x, this.y, {x: Math.cos(angle), y: Math.sin(angle)}, 300));
                        }
                    }
                    this.x += (dx/dist) * this.speed * dt;
                    this.y += (dy/dist) * this.speed * dt;
                }
                this.shooterTimer -= dt;
            }

            draw(ctx) {
                ctx.save();
                if (this.isFading) {
                    ctx.globalAlpha = 0.2;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                const gradient = ctx.createRadialGradient(this.x, this.y, this.radius, this.x, this.y, this.radius * 2);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                if (this.isFrozen) {
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.type = type;
                this.color = this.getColor();
                this.opacity = 1;
                this.isDead = false;
                this.spawnedTime = Date.now();
            }

            getColor() {
                switch (this.type) {
                    case 'shield': return '#00aaff';
                    case 'freeze': return '#00ffff';
                    case 'crystal': return '#ffdd00';
                    case 'slow_mo': return '#8a2be2';
                    case 'double_score': return '#ff69b4';
                    default: return '#fff';
                }
            }

            update(dt) {
                const lifespan = 10000;
                if (Date.now() - this.spawnedTime > lifespan) {
                    this.opacity -= dt;
                    if (this.opacity <= 0) {
                        this.isDead = true;
                    }
                }
                if (particles.length < config.particles.maxParticles) {
                    const spawnCount = Math.max(1, Math.round(config.particles.itemGlowDensity / 2));
                    for (let i = 0; i < spawnCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * this.radius * 0.5;
                        particles.push(getParticle(
                            this.x + Math.cos(angle) * r,
                            this.y + Math.sin(angle) * r,
                            { x: Math.cos(angle), y: Math.sin(angle) },
                            '#fff',
                            Math.random() * 2 + 1,
                            0.5
                        ));
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.vx = velocity.x * (Math.random() * 50 + 20);
                this.vy = velocity.y * (Math.random() * 50 + 20);
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.fadeRate = 1 / life;
            }

            reset(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.vx = velocity.x * (Math.random() * 50 + 20);
                this.vy = velocity.y * (Math.random() * 50 + 20);
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.fadeRate = 1 / life;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life * this.fadeRate);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Obstacle {
            constructor(x, y, width, height, isMovable = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isMovable = isMovable;
                this.color = '#1a1a1a';
                this.direction = {x: 0, y: 0};
                if (isMovable) {
                    const ang = Math.random() * Math.PI * 2;
                    this.direction = {x: Math.cos(ang), y: Math.sin(ang)};
                }
            }

            update(dt) {
                if (this.isMovable) {
                    this.x += this.direction.x * 50 * dt;
                    this.y += this.direction.y * 50 * dt;

                    // Bounce off walls
                    if (this.x < 0 || this.x + this.width > canvas.width) {
                        this.direction.x *= -1;
                    }
                    if (this.y < 0 || this.y + this.height > canvas.height) {
                        this.direction.y *= -1;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // =================================================================
        // Game Manager
        // =================================================================

        const gameManager = {
            score: 0,
            wave: 1,
            isWaveActive: false,
            waveStartTime: 0,
            init() {
                this.score = 0;
                this.wave = 1;
                this.isWaveActive = false;
                this.waveStartTime = 0;
                enemies = [];
                items = [];
                particles = [];
                projectiles = [];
                playerProjectiles = [];
                enemySpawnTimer = 0;
                currentWaveDuration = 0;
                obstacles = [];
                
                // reset missions on new game
                missions = config.missions.map(m => ({ ...m, completed: false }));
                localStorage.setItem('missions', JSON.stringify(missions));


                player = new Player(canvas.width / 2, canvas.height / 2);
                this.updateHUD();
            },
            updateHUD() {
                const scoreElement = document.getElementById('score');
                const waveElement = document.getElementById('wave');
                const shieldElement = document.getElementById('shield-time');
                const comboElement = document.getElementById('combo-count');

                if (scoreElement) scoreElement.textContent = Math.round(this.score);
                if (waveElement) waveElement.textContent = this.wave;
                if (player && shieldElement) {
                    shieldElement.textContent = player.shieldTime > 0 ? player.shieldTime.toFixed(1) : '0';
                    const progress = player.maxShieldTime > 0 ? (player.shieldTime / player.maxShieldTime) * 100 : 0;
                    shieldProgressBar.style.width = `${progress}%`;
                }
                if (player && comboElement) comboElement.textContent = player.combo;

                if (boss) {
                    bossHealthBar.style.opacity = 1;
                    const progress = (boss.health / boss.maxHealth) * 100;
                    bossHealthProgress.style.width = `${progress}%`;
                } else {
                    bossHealthBar.style.opacity = 0;
                }
            },
            updateMissions(type, enemyType = null, amount = 0) {
                missions.forEach(mission => {
                    if (mission.completed) return;
                    
                    if (mission.type === 'kill' && type === 'kill') {
                        if (mission.enemy === 'any' || mission.enemy === enemyType) {
                            mission.count--;
                            if (mission.count <= 0) {
                                mission.completed = true;
                                this.score += mission.reward;
                                showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                            }
                        }
                    } else if (mission.type === 'score' && type === 'score') {
                        if (this.score >= mission.amount) {
                            mission.completed = true;
                            this.score += mission.reward;
                            showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                        }
                    }
                });
                localStorage.setItem('missions', JSON.stringify(missions));
            },
            startWave() {
                this.isWaveActive = true;
                currentWaveDuration = config.waves.waveDuration + this.wave * config.waves.waveDurationGrowth;
                enemySpawnTimer = 0;

                if (this.wave % config.waves.bossWaveInterval === 0) {
                    this.spawnBoss();
                } else {
                    const initialEnemies = config.waves.minEnemies;
                    this.spawnInitialEnemies(initialEnemies);
                }
            },
            spawnBoss() {
                boss = new Enemy(canvas.width / 2, -100, 'boss');
                boss.maxHealth = 500;
                boss.health = 500;
                boss.color = '#ff0000';
                boss.radius = 40;
                enemies.push(boss);
                if (audioManager) audioManager.playSfx('boss_spawn');
            },
            spawnInitialEnemies(count) {
                const enemyTypes = ['chaser', 'wanderer', 'shifter', 'bomber', 'shooter', 'splinterer', 'teleporter', 'armored', 'pattern_shooter'];
                for (let i = 0; i < count; i++) {
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (side) {
                        case 0: x = -config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 1: x = canvas.width + config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = -config.enemies.spawnDistance; break;
                        case 3: x = Math.random() * canvas.width; y = canvas.height + config.enemies.spawnDistance; break;
                    }
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    enemies.push(new Enemy(x, y, type));
                }
            },
            spawnItems() {
                if (Math.random() < config.items.spawnRate) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const rand = Math.random();
                    let itemType;
                    const raritySum = config.items.rarity.shield + config.items.rarity.freeze + config.items.rarity.crystal + config.items.rarity.slow_mo + config.items.rarity.double_score;
                    if (rand < config.items.rarity.shield) {
                        itemType = 'shield';
                    } else if (rand < config.items.rarity.shield + config.items.rarity.freeze) {
                        itemType = 'freeze';
                    } else if (rand < config.items.rarity.shield + config.items.rarity.freeze + config.items.rarity.crystal) {
                        itemType = 'crystal';
                    } else if (rand < raritySum - config.items.rarity.double_score) {
                        itemType = 'slow_mo';
                    } else {
                        itemType = 'double_score';
                    }
                    items.push(new Item(x, y, itemType));
                }
            },
            showUpgradeScreen() {
                isPaused = true;
                hideAllPanels();
                upgradeMenu.classList.add('visible');
                const upgradeOptionsDiv = document.getElementById('upgrade-options');
                upgradeOptionsDiv.innerHTML = '';
                
                // Add an option to upgrade projectile type
                const projectileUpgradeOption = {
                    name: 'شلیک سه‌تایی',
                    description: 'شلیک سه تیر به جای یک تیر با زاویه ±۱۵ درجه',
                    effect: (player) => player.setProjectileType('triple')
                };
                
                const availableUpgrades = [...config.upgrades.options, projectileUpgradeOption];
                for (let i = 0; i < config.upgrades.optionCount; i++) {
                    if (availableUpgrades.length === 0) break;
                    const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
                    const upgrade = availableUpgrades.splice(randomIndex, 1)[0];

                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
                    card.addEventListener('click', () => {
                        upgrade.effect(player);
                        this.wave++;
                        hideAllPanels();
                        gameActive = true;
                        isPaused = false;
                        this.startWave();
                    });
                    upgradeOptionsDiv.appendChild(card);
                }
            },
            showShopScreen() {
                isPaused = true;
                hideAllPanels();
                shopMenu.classList.add('half-visible');
                const shopItemsDiv = document.getElementById('shop-items');
                shopItemsDiv.innerHTML = '';
                
                const shopScore = document.getElementById('shop-score');
                shopScore.textContent = Math.round(this.score);

                shopItems.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.innerHTML = `<h3>${item.name}</h3><p>${item.description}</p><span class="price">${item.price}</span>`;
                    
                    const isPurchased = persistentUpgrades[item.id];
                    if (isPurchased) {
                        card.classList.add('purchased');
                        card.innerHTML = `<h3>${item.name}</h3><p>${item.description}</p><span class="price">خریداری شد</span>`;
                        card.style.cursor = 'not-allowed';
                    } else {
                        card.addEventListener('click', () => {
                            if (this.score >= item.price) {
                                this.score -= item.price;
                                item.effect(player);
                                persistentUpgrades[item.id] = true;
                                localStorage.setItem('persistentUpgrades', JSON.stringify(persistentUpgrades));
                                this.showShopScreen(); // Reload shop to show item as purchased
                            } else {
                                showMessage('امتیاز کافی برای خرید این آیتم ندارید.');
                            }
                        });
                    }
                    
                    shopItemsDiv.appendChild(card);
                });
            },
            showMissionsScreen() {
                isPaused = true;
                hideAllPanels();
                missionsMenu.classList.add('half-visible');
                const missionsListDiv = document.getElementById('missions-list');
                missionsListDiv.innerHTML = '';

                missions.forEach(mission => {
                    const card = document.createElement('div');
                    card.className = 'mission-item';
                    card.innerHTML = `<h3>${mission.description}</h3><span class="status">${mission.completed ? 'تکمیل شد' : 'در حال انجام'}</span>`;
                    if (mission.completed) {
                        card.classList.add('completed');
                    }
                    missionsListDiv.appendChild(card);
                });
            },
        };

        // =================================================================
        // Main Game Loop and Logic
        // =================================================================
        function startScreenShake() {
            screenShakeTime = SCREEN_SHAKE_DURATION;
        }

        function hideAllPanels() {
            [mainMenu, tutorialMenu, gameOverMenu, upgradeMenu, settingsMenu, shopMenu, missionsMenu].forEach(panel => panel.classList.remove('visible', 'half-visible'));
        }

        function showPanel(panel) {
            hideAllPanels();
            panel.classList.add('visible');
        }

        function showMessage(text) {
            messageText.innerHTML = text;
            messageBox.style.display = 'block';
            isPaused = true;
        }

        function showLoading() {
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        async function getMagicalUpgrade() {
            showLoading();
            const prompt = `Based on a survival game where the player is a light and enemies are shadows, generate a single, unique upgrade. The upgrade should be concise (name and a short description), and directly applicable to the player's attributes. Output a JSON object with keys "name", "description", and a "type" string which can be 'speed', 'shield', 'combo' or 'score'. Do not output any other text besides the JSON. Example output: {"name": "Light Speed", "description": "Doubles player speed for 5 seconds.", "type": "speed"}`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "name": { "type": "STRING" },
                                "description": { "type": "STRING" },
                                "type": { "type": "STRING" }
                            }
                        }
                    }
                };
                const apiKey = "";
                let response = null;
                const maxRetries = 5;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                    } catch (e) {
                        console.error('Fetch failed, retrying...', e);
                    }
                    await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i)));
                }

                if (!response || !response.ok) {
                    throw new Error('API call failed after multiple retries.');
                }

                const result = await response.json();
                const json = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!json) {
                    throw new Error('Invalid response from API.');
                }
                const magicalUpgrade = JSON.parse(json);

                switch (magicalUpgrade.type) {
                    case 'speed':
                        player.speed *= 1.25;
                        break;
                    case 'shield':
                        player.shieldTime += 10;
                        player.maxShieldTime += 10;
                        break;
                    case 'combo':
                        player.comboMultiplier += 0.5;
                        break;
                    case 'score':
                        gameManager.score += 500;
                        break;
                    default:
                        gameManager.score += 250;
                        break;
                }

                showMessage(`✨ ارتقاء جادویی: ${magicalUpgrade.name}<br>${magicalUpgrade.description}`);

            } catch (error) {
                console.error('Error fetching magical upgrade:', error);
                const fallbackUpgrade = config.upgrades.offlineUpgrades[Math.floor(Math.random() * config.upgrades.offlineUpgrades.length)];
                switch (fallbackUpgrade.type) {
                    case 'shield':
                        player.shieldTime += 10;
                        player.maxShieldTime += 10;
                        break;
                    case 'score':
                        gameManager.score += 500;
                        break;
                }
                showMessage(`خطا در دریافت ارتقاء جادویی. یک ارتقاء ساده اعمال شد: ${fallbackUpgrade.name}`);
            } finally {
                hideLoading();
            }
        }

        async function readTutorialText() {
            showLoading();
            const tutorialText = document.querySelector('#tutorial-text').innerText;
            const prompt = `Say in a calm and clear male voice, speaking in Persian: ${tutorialText}`;
            try {
                const payload = {
                    contents: [{
                        parts: [{ text: prompt }]
                    }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Rasalgethi" }
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };
                const apiKey = "";
                let response = null;
                const maxRetries = 5;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                    } catch (e) {
                        console.error('Fetch failed, retrying...', e);
                    }
                    await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i)));
                }

                if (!response || !response.ok) {
                    throw new Error('API call failed after multiple retries.');
                }

                const result = await response.json();
                const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

                const m = (mimeType || '').match(/rate=(\d+)/);
                const sampleRate = m ? parseInt(m[1], 10) : 24000;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);

                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    showMessage("خطا در تولید صدای آموزش.");
                }
            } catch (error) {
                console.error('Error generating TTS:', error);
                showMessage("خطا در تولید صدای آموزش.");
            } finally {
                hideLoading();
            }
        }

        // Helper functions for TTS
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const dataLength = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);

            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset, pcmData[i], true);
                offset += 2;
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function startGame() {
            gameManager.init();
            hideAllPanels();
            gameActive = true;
            isPaused = false;
            gameManager.startWave();
            if (audioManager && audioManager.isInitialized) {
                audioManager.playAmbience();
            }
        }

        function handleCollisions() {
            if (!player) return;

            // Player vs Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + enemy.radius + config.player.comboNearMissDistance) {
                    if (comboDisplay && Math.random() < 0.005) {
                        player.combo++;
                        player.comboBonus += player.combo * config.player.comboBonusMultiplier;
                        comboDisplay.textContent = `Combo! x${player.combo}`;
                        comboDisplay.style.opacity = 1;
                        setTimeout(() => comboDisplay.style.opacity = 0, 500);
                    }
                }

                if (distance < player.radius + enemy.radius) {
                    if (player.shieldTime > 0) {
                        player.shieldTime--;
                        gameManager.score += 10;
                        if (enemy.type === 'splinterer') {
                             for (let j = 0; j < 3; j++) {
                                const ang = Math.random() * Math.PI * 2;
                                enemies.push(new Enemy(enemy.x, enemy.y, 'chaser'));
                             }
                        }
                        gameManager.updateMissions('kill', enemy.type);
                        enemies.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                    } else {
                        endGame();
                        return;
                    }
                }
            }

            // Player vs Enemy Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                const dx = player.x - projectile.x;
                const dy = player.y - projectile.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + projectile.radius) {
                    if (player.shieldTime > 0) {
                        player.shieldTime--;
                        projectiles.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                    } else {
                        endGame();
                        return;
                    }
                }
            }
            
            // Player vs Obstacles
            for (const obstacle of obstacles) {
                const dx = player.x - Math.max(obstacle.x, Math.min(player.x, obstacle.x + obstacle.width));
                const dy = player.y - Math.max(obstacle.y, Math.min(player.y, obstacle.y + obstacle.height));
                if (Math.hypot(dx, dy) < player.radius) {
                    endGame();
                    return;
                }
            }

            // Player Projectiles vs Enemies
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const p = playerProjectiles[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dx = p.x - e.x;
                    const dy = p.y - e.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist < p.radius + e.radius) {
                        // Handle collision based on projectile type
                        if (p instanceof BombProjectile && p.isExploded) {
                            const explDist = Math.hypot(p.x - e.x, p.y - e.y);
                            if (explDist < p.explosionRadius) {
                                e.health -= p.damage * (1 - e.damageReduction);
                            }
                        } else if (p instanceof LaserProjectile) {
                            if (!p.hitEnemies.has(e)) {
                                e.health -= p.damage * (1 - e.damageReduction);
                                p.hitEnemies.add(e);
                            }
                        } else {
                            e.health -= p.damage * (1 - e.damageReduction);
                            p.isDead = true;
                        }
                        
                        if (e.health <= 0) {
                            if (e.isBoss) {
                                gameManager.score += 1000;
                                startScreenShake();
                                if (audioManager) audioManager.playSfx('boss_explosion'); // Guarded audio call
                                boss = null;
                                enemies.splice(j, 1);
                                for (let k=0; k<5; k++) {
                                     items.push(new Item(e.x + Math.random()*50-25, e.y + Math.random()*50-25, 'crystal'));
                                }
                                showMessage('باس شکست خورد! یک ارتقاء ویژه دریافت کردید.');
                                gameManager.isWaveActive = false;
                                waveTimer = config.waves.wavePauseDuration;
                            } else {
                                gameManager.score += 20;
                                gameManager.updateMissions('kill', e.type);
                                enemies.splice(j, 1);
                                if (audioManager) audioManager.playSfx('hit');
                            }
                        }
                    }
                }
            }

            // Player-Item collisions
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + item.radius) {
                    switch (item.type) {
                        case 'shield':
                            player.shieldTime += 3;
                            player.maxShieldTime += 3;
                            break;
                        case 'freeze':
                            enemies.forEach(e => {
                                e.isFrozen = true;
                                setTimeout(() => e.isFrozen = false, 2000);
                            });
                            if (audioManager) audioManager.playSfx('freeze'); // Guarded audio call
                            break;
                        case 'crystal':
                            gameManager.score += 25;
                            break;
                        case 'slow_mo':
                            isSlowMotion = true;
                            slowMotionTimer = 4;
                            if (audioManager) audioManager.playSfx('slow_mo'); // Guarded audio call
                            break;
                        case 'double_score':
                            scoreMultiplier = 2;
                            setTimeout(() => scoreMultiplier = 1, 8000);
                            break;
                    }
                    items.splice(i, 1);
                    if (audioManager) audioManager.playSfx('pickup'); // Guarded audio call
                }
            }
        }
        
        function spawnContinuousEnemies(dt) {
            if (gameManager.isWaveActive && !boss) {
                enemySpawnTimer -= dt;
                if (enemySpawnTimer <= 0) {
                    // افزایش تنوع و تعداد دشمنان با پیشرفت موج
                    const enemyTypes = ['chaser', 'wanderer', 'shifter', 'bomber', 'shooter', 'splinterer', 'teleporter', 'armored', 'pattern_shooter'];
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (side) {
                        case 0: x = -config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 1: x = canvas.width + config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = -config.enemies.spawnDistance; break;
                        case 3: x = Math.random() * canvas.width; y = canvas.height + config.enemies.spawnDistance; break;
                    }
                    enemies.push(new Enemy(x, y, type));
                    
                    // نرخ اسپاون را بر اساس موج فعلی تنظیم کنید
                    const spawnRate = config.enemies.spawnRatePerWave / (1 + gameManager.wave * 0.1);
                    enemySpawnTimer = spawnRate;
                }
            }
        }


        function endGame() {
            gameActive = false;
            isPaused = true;
            showPanel(gameOverMenu);
            const finalScoreElement = document.getElementById('final-score');
            const finalWaveElement = document.getElementById('final-wave');
            if(finalScoreElement) finalScoreElement.textContent = Math.round(gameManager.score);
            if(finalWaveElement) finalWaveElement.textContent = gameManager.wave;

            if (gameManager.score > highscore) {
                highscore = Math.round(gameManager.score);
                localStorage.setItem('shadow_escape_highscore', highscore);
                document.getElementById('highscore-display').textContent = highscore;
            }
            if (audioManager && audioManager.isInitialized) {
                audioManager.pauseAmbience();
            }
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function gameLoop(timestamp) {
            if (gameActive) {
                document.body.style.cursor = 'none';
            } else {
                document.body.style.cursor = 'default';
            }

            if (!gameActive) {
                lastTime = timestamp;
                requestAnimationFrame(gameLoop);
                return;
            }

            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (isSlowMotion) {
                dt *= 0.5;
                slowMotionTimer -= dt;
                if (slowMotionTimer <= 0) {
                    isSlowMotion = false;
                }
            }

            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (screenShakeTime > 0) {
                screenShakeTime -= dt;
                const shakeIntensity = 10 * (screenShakeTime / SCREEN_SHAKE_DURATION);
                screenShakeX = (Math.random() - 0.5) * shakeIntensity;
                screenShakeY = (Math.random() - 0.5) * shakeIntensity;
            } else {
                screenShakeX = 0;
                screenShakeY = 0;
            }
            mainContainer.style.transform = `translate(${screenShakeX}px, ${screenShakeY}px)`;

            if (player) {
                const inputVector = inputManager.getMovementVector();
                player.update(dt, inputVector);
                gameManager.score += dt * (1 + player.comboBonus) * scoreMultiplier;
            }
            
            gameManager.updateMissions('score');

            spawnContinuousEnemies(dt);

            enemies.forEach(enemy => {
                if (player) {
                    enemy.update(dt);
                }
            });
            items.forEach(item => item.update(dt));
            projectiles.forEach(p => p.update(dt));
            playerProjectiles.forEach(p => p.update(dt));
            obstacles.forEach(o => o.update(dt));

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(dt);
            }

            enemies = enemies.filter(enemy => {
                const isOffScreen = enemy.x < -config.enemies.spawnDistance * 2 || enemy.x > canvas.width + config.enemies.spawnDistance * 2 ||
                                   enemy.y < -config.enemies.spawnDistance * 2 || enemy.y > canvas.height + config.enemies.spawnDistance * 2;
                return !isOffScreen;
            });
            items = items.filter(item => !item.isDead);
            particles = particles.filter(p => p.life > 0);
            projectiles = projectiles.filter(p => !p.isDead);
            playerProjectiles = playerProjectiles.filter(p => !p.isDead);
            
            if (player) {
                handleCollisions();
            }

            gameManager.updateHUD();

            if (gameManager.isWaveActive) {
                currentWaveDuration -= dt;
                waveTimerDisplay.textContent = Math.max(0, currentWaveDuration).toFixed(0);
                if (currentWaveDuration <= 0 && !boss) {
                    gameManager.isWaveActive = false;
                    waveTimer = config.waves.wavePauseDuration;
                }
            } else {
                waveTimer -= dt;
                if (waveTimer <= 0) {
                    gameManager.showUpgradeScreen();
                }
            }
            
            gameManager.spawnItems();

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (player) {
                const waveHue = (gameManager.wave * 40) % 360;
                const dynamicColor = `hsl(${waveHue}, 80%, 70%)`;
                const bgGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, Math.max(canvas.width, canvas.height) * 0.7);

                const waveRgb = hexToRgb(dynamicColor);
                if (waveRgb) {
                    bgGradient.addColorStop(0, `rgba(${waveRgb.r}, ${waveRgb.g}, ${waveRgb.b}, 0.05)`);
                } else {
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                }
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            obstacles.forEach(o => o.draw(ctx));

            particles.forEach(p => p.draw(ctx));
            items.forEach(item => item.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            playerProjectiles.forEach(p => p.draw(ctx));
            enemies.forEach(enemy => enemy.draw(ctx));
            if (player) {
                player.draw(ctx);
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        };

        document.addEventListener('DOMContentLoaded', () => {
            const hsEl = document.getElementById('highscore-display');
            if (hsEl) hsEl.textContent = highscore;

            resizeCanvas();

            inputManager.init();
            audioManager = new AudioManager();

            const $ = (id) => document.getElementById(id);
            const musicVolumeInput = $('music-volume');
            const sfxVolumeInput = $('sfx-volume');
            const mouseSensitivityInput = $('mouse-sensitivity');

            musicVolumeInput.value = musicVolume;
            sfxVolumeInput.value = sfxVolume;
            mouseSensitivityInput.value = mouseSensitivity;

            musicVolumeInput.addEventListener('input', (e) => {
                musicVolume = parseFloat(e.target.value);
                if (audioManager) audioManager.updateVolumes(musicVolume, sfxVolume);
            });
            sfxVolumeInput.addEventListener('input', (e) => {
                sfxVolume = parseFloat(e.target.value);
                if (audioManager) audioManager.updateVolumes(musicVolume, sfxVolume);
            });
            mouseSensitivityInput.addEventListener('input', (e) => {
                mouseSensitivity = parseFloat(e.target.value);
                localStorage.setItem('mouseSensitivity', mouseSensitivity);
            });

            $('play-button').addEventListener('click', () => {
                audioManager.init();
                startGame();
            });

            $('shop-button').addEventListener('click', () => {
                gameManager.showShopScreen();
            });

            $('tutorial-button').addEventListener('click', () => {
                showPanel(tutorialMenu);
            });

            $('settings-button').addEventListener('click', () => {
                showPanel(settingsMenu);
            });

            $('back-to-main').addEventListener('click', () => {
                showPanel(mainMenu);
            });
            
            $('back-from-missions').addEventListener('click', () => {
                gameManager.showUpgradeScreen();
            });
            
            $('back-to-main-from-shop').addEventListener('click', () => {
                showPanel(mainMenu);
            });

            $('back-to-main-from-settings').addEventListener('click', () => {
                showPanel(mainMenu);
            });
            
            $('show-missions-button').addEventListener('click', () => {
                gameManager.showMissionsScreen();
            });

            $('retry-button').addEventListener('click', () => {
                startGame();
            });

            $('back-to-main-from-gameover').addEventListener('click', () => {
                showPanel(mainMenu);
            });

            $('magical-upgrade-button').addEventListener('click', () => {
                getMagicalUpgrade();
            });

            $('read-tutorial-button').addEventListener('click', () => {
                readTutorialText();
            });

            audioToggle.addEventListener('click', () => {
                if (audioManager) audioManager.toggleMute();
            });

            $('message-close-button').addEventListener('click', () => {
                messageBox.style.display = 'none';
                isPaused = false;
            });
            
            // Event listener for the new shoot button
            if (shootBtn) {
                shootBtn.addEventListener('click', () => {
                    if (gameActive && player) {
                        player.shoot();
                    }
                });
            }

            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
