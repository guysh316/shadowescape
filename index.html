<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Scape</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');

        body {
            background-color: #0d0c1d;
            color: #d1d1e9;
            font-family: 'Vazirmatn', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            cursor: default;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 200px rgba(0, 0, 0, 0.5) inset;
        }

        canvas {
            background: linear-gradient(135deg, #0d0c1d, #0d0c1d 50%, #15142f);
            display: block;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: rgba(13, 12, 29, 0.95);
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 100;
        }

        .screen.active {
            display: flex;
            opacity: 1;
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            text-shadow: 0 0 20px #8affff, 0 0 40px #00ffff;
            animation: pulse-glow 2s infinite alternate;
            color: #e9e9ff;
            margin-bottom: 2rem;
        }

        @keyframes pulse-glow {
            from { text-shadow: 0 0 20px #8affff, 0 0 40px #00ffff; }
            to { text-shadow: 0 0 30px #e0ffff, 0 0 60px #50e3ff; }
        }

        .message {
            font-size: 1.5rem;
            text-align: center;
            margin-top: 1rem;
            color: #d1d1e9;
        }

        .input-group {
            margin-top: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .input-group label {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .input-group input {
            padding: 0.75rem 1rem;
            font-size: 1rem;
            border-radius: 10px;
            border: 2px solid #50e3ff;
            background-color: #1e1d3d;
            color: #e9e9ff;
            outline: none;
            transition: border-color 0.3s ease;
            text-align: center;
        }

        .input-group input:focus {
            border-color: #e0ffff;
        }

        .input-group button, .menu-button, .back-button {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background-image: linear-gradient(45deg, #1e1d3d, #2a294b);
            color: #e9e9ff;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin-top: 1rem;
            position: relative;
            overflow: hidden;
        }

        .menu-button:hover, .input-group button:hover, .back-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background-image: linear-gradient(45deg, #2a294b, #3c3b61);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .store-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1e1d3d;
            border: 2px solid #50e3ff;
            border-radius: 15px;
            padding: 1.5rem;
            width: 250px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
            margin: 1rem;
            cursor: pointer;
        }

        .store-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .store-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            padding: 2rem;
            max-height: 70vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #50e3ff #1e1d3d;
        }

        .store-grid::-webkit-scrollbar {
            width: 8px;
        }

        .store-grid::-webkit-scrollbar-track {
            background: #1e1d3d;
        }

        .store-grid::-webkit-scrollbar-thumb {
            background-color: #50e3ff;
            border-radius: 20px;
            border: 2px solid #1e1d3d;
        }

        .stats-panel, .codex-panel {
            background-color: rgba(13, 12, 29, 0.95);
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #50e3ff #1e1d3d;
        }

        .stats-panel::-webkit-scrollbar, .codex-panel::-webkit-scrollbar {
            width: 8px;
        }

        .stats-panel::-webkit-scrollbar-track, .codex-panel::-webkit-scrollbar-track {
            background: #1e1d3d;
        }

        .stats-panel::-webkit-scrollbar-thumb, .codex-panel::-webkit-scrollbar-thumb {
            background-color: #50e3ff;
            border-radius: 20px;
            border: 2px solid #1e1d3d;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(13, 12, 29, 0.95);
            border: 2px solid #50e3ff;
            border-radius: 15px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 200;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            text-align: center;
        }

        #game-over-screen .modal {
            width: 400px;
        }

        #game-over-screen .modal .title {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        #game-over-screen .modal .message {
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }
        
        #game-over-screen .modal .message:last-of-type {
            font-size: 1.5rem;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .codex-entry {
            margin-bottom: 2rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #3c3b61;
        }

        .codex-entry:last-child {
            border-bottom: none;
        }

        .codex-entry h3 {
            font-size: 1.5rem;
            color: #50e3ff;
            text-shadow: 0 0 10px #50e3ff;
        }

        .codex-entry p {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .ui-text {
            font-size: 1.2rem;
            text-align: center;
            margin: 0.5rem 0;
            color: #e9e9ff;
        }

        .ui-text.small {
            font-size: 1rem;
            color: #a0a0b0;
        }

        .performance-options {
            display: flex;
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .performance-option {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border-radius: 10px;
            border: 2px solid transparent;
            background-image: linear-gradient(45deg, #1e1d3d, #2a294b);
            color: #e9e9ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .performance-option.selected, .performance-option:hover {
            border-color: #50e3ff;
            background-image: linear-gradient(45deg, #2a294b, #3c3b61);
            box-shadow: 0 0 15px #50e3ff;
            transform: translateY(-3px);
        }

        #game-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            color: #e9e9ff;
            text-align: right;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        #boss-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        #boss-hp-bar {
            width: 100%;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            position: relative;
        }
        
        #boss-hp-fill {
            height: 100%;
            background-color: #ff0000;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        #boss-name {
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 5px #ff0000;
            margin-top: 10px;
        }

        #game-hud div {
            padding: 5px 10px;
            background-color: rgba(13, 12, 29, 0.7);
            border-radius: 5px;
        }

        #dps-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff5050;
            font-size: 2rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(13, 12, 29, 0.95);
            border: 2px solid #ff5050;
            border-radius: 15px;
            padding: 2rem;
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 80, 80, 0.2);
        }

        .message-box .message-text {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .message-box .message-button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 8px;
            background-image: linear-gradient(45deg, #ff5050, #d93d3d);
            color: #e9e9ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .message-box .message-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(255, 80, 80, 0.4);
        }
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .ui-text {
            animation: fade-in 1s ease;
        }

        @keyframes explode {
            from { transform: scale(0.5); opacity: 1; }
            to { transform: scale(2); opacity: 0; }
        }
        .explosion-particle {
            animation: explode 0.5s forwards;
            background-color: #ff0000;
            border-radius: 50%;
        }

        @keyframes screen-shake {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            60% { transform: translate(-5px, 5px); }
            80% { transform: translate(5px, -5px); }
            100% { transform: translate(0, 0); }
        }
        .shaking {
            animation: screen-shake 0.3s ease-in-out;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <audio id="fire-sound" src="sounds/fire.wav" preload="auto"></audio>
        <audio id="explosion-sound" src="sounds/explosion.mp3" preload="auto"></audio>
        <audio id="background-music" src="music/game-theme.mp3" loop></audio>
        <audio id="boss-music" src="music/boss-theme.mp3" loop></audio>
        <audio id="ui-click" src="sounds/ui-click.wav" preload="auto"></audio>
        <audio id="damage-sound" src="sounds/damage.wav" preload="auto"></audio>
        <audio id="player-death" src="sounds/player-death.wav" preload="auto"></audio>
        <audio id="level-up" src="sounds/level-up.wav" preload="auto"></audio>

        <div id="desktop-only-screen" class="screen">
            <h1 class="title">توجه!</h1>
            <p class="message">این بازی فقط برای دسکتاپ (کامپیوتر/لپ‌تاپ) طراحی شده است.<br>لطفاً از یک دستگاه مناسب استفاده کنید.</p>
        </div>

        <div id="splash-screen" class="screen active">
            <h1 class="title">Shadow Scape</h1>
            <div class="input-group">
                <label for="username-input">نام خود را وارد کنید:</label>
                <input type="text" id="username-input" placeholder="نام کاربری">
                <button id="start-button">شروع بازی</button>
            </div>
        </div>

        <div id="main-menu-screen" class="screen">
            <h1 class="title">منوی اصلی</h1>
            <div class="menu-buttons">
                <button id="start-game-button" class="menu-button">شروع بازی جدید</button>
                <button id="continue-game-button" class="menu-button">ادامه بازی</button>
                <button id="store-button" class="menu-button">فروشگاه</button>
                <button id="codex-button" class="menu-button">کودکس</button>
                <button id="settings-button" class="menu-button">تنظیمات</button>
            </div>
        </div>

        <div id="settings-screen" class="screen">
            <h1 class="title">تنظیمات</h1>
            <p class="ui-text">حالت عملکرد:</p>
            <div class="performance-options">
                <button id="perf-low" class="performance-option">پایین</button>
                <button id="perf-medium" class="performance-option">متوسط</button>
                <button id="perf-high" class="performance-option">بالا</button>
            </div>
            <p class="ui-text">دسترس‌پذیری:</p>
            <div class="performance-options">
                <button id="acc-contrast" class="performance-option">کنتراست بالا</button>
                <button id="acc-motion" class="performance-option">کاهش حرکت</button>
            </div>
            <button id="back-to-menu-from-settings" class="back-button">بازگشت</button>
        </div>

        <div id="store-screen" class="screen">
            <h1 class="title">فروشگاه</h1>
            <div class="ui-text">
                اعتبار: <span id="credit-display">0</span> |
                کلید: <span id="key-display">0</span> |
                تکه: <span id="shard-display">0</span>
            </div>
            <div class="store-grid" id="store-grid"></div>
            <button id="back-to-menu-from-store" class="back-button">بازگشت</button>
        </div>

        <div id="codex-screen" class="screen">
            <h1 class="title">کودکس خاطرات</h1>
            <div id="codex-entries" class="stats-panel"></div>
            <button id="back-to-menu-from-codex" class="back-button">بازگشت</button>
        </div>

        <div id="wave-intermission-screen" class="screen">
            <h1 class="title">میان‌وقفه موج</h1>
            <div id="intermission-message" class="message"></div>
            <button id="intermission-continue" class="menu-button">ادامه</button>
            <button id="intermission-store" class="menu-button">بازدید از فروشگاه</button>
        </div>

        <div id="game-over-screen" class="screen">
            <div class="modal">
                <h2 class="title">بازی تمام شد</h2>
                <p class="message">امتیاز نهایی: <span id="final-score">0</span></p>
                <div class="modal-buttons">
                    <button id="game-over-restart" class="menu-button">شروع مجدد</button>
                    <button id="game-over-continue" class="menu-button" style="display:none;">ادامه با Key</button>
                    <button id="game-over-menu" class="menu-button">منوی اصلی</button>
                </div>
            </div>
        </div>

        <div id="game-hud">
            <div>موج: <span id="hud-wave">1</span></div>
            <div>HP: <span id="hud-hp">100</span></div>
            <div>امتیاز: <span id="hud-score">0</span></div>
            <div>زمان: <span id="hud-timer">90</span>s</div>
            <div>FPS: <span id="hud-fps">0</span></div>
            <div>توکن‌ها: <span id="hud-credit">0</span></div>
            <div>کلید: <span id="hud-keys">0</span></div>
        </div>
        
        <div id="boss-hud">
            <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
            <span id="boss-name"></span>
        </div>

        <div id="dps-message"></div>
        <div class="message-box" id="global-message-box">
            <p class="message-text" id="global-message-text"></p>
            <button class="message-button" id="global-message-button">تایید</button>
        </div>
    </div>

    <script>
        // Data-driven design: JSON data represented as JS objects
        const gameData = {
            enemies: {
                "shadow_moth": { "id": "shadow_moth", "name": "پروانه سایه", "tier": 0, "color": "hsl(220, 50%, 50%)", "baseSpeed": 1, "baseHp": 5, "damage": 1, "pattern": "zigzag", "animPattern": "pulse", "dropTable": { "credit": 10, "shard": 0 } },
                "slow_giant": { "id": "slow_giant", "name": "غول کند", "tier": 1, "color": "hsl(240, 30%, 30%)", "baseSpeed": 0.5, "baseHp": 30, "damage": 5, "pattern": "seek", "animPattern": "wobble", "dropTable": { "credit": 50, "shard": 0 } },
                "ranged_stalker": { "id": "ranged_stalker", "name": "تعقیب‌کننده دوربرد", "tier": 2, "color": "hsl(270, 40%, 40%)", "baseSpeed": 1.5, "baseHp": 10, "damage": 2, "pattern": "ranged", "animPattern": "flicker", "dropTable": { "credit": 25, "shard": 0 } }
            },
            bosses: {
                "serpent": { "id": "serpent", "name": "Shadow Serpent", "color": "#ff0000", "radius": 40, "phases": [{ "hp": 300, "speed": 100, "attack": "charge_player" }, { "hp": 200, "speed": 120, "attack": "spawn_bullets" }] },
                "void_eye": { "id": "void_eye", "name": "Void Eye", "color": "#9400d3", "radius": 35, "phases": [{ "hp": 250, "speed": 80, "attack": "spawn_minions" }, { "hp": 180, "speed": 95, "attack": "laser_beam" }, { "hp": 120, "speed": 110, "attack": "teleport_and_shoot" }] },
                "night_walker": { "id": "night_walker", "name": "Night Walker", "color": "#00ffff", "radius": 50, "phases": [{ "hp": 400, "speed": 60, "attack": "shockwave" }, { "hp": 280, "speed": 75, "attack": "teleport_and_stomp" }] },
                "dark_titan": { "id": "dark_titan", "name": "Dark Titan", "color": "#ffaa00", "radius": 55, "phases": [{ "hp": 450, "speed": 50, "attack": "slow_meteor" }, { "hp": 300, "speed": 65, "attack": "spawn_bombers" }, { "hp": 150, "speed": 80, "attack": "rapid_shot" }] },
                "phantom_king": { "id": "phantom_king", "name": "Phantom King", "color": "#ff69b4", "radius": 45, "phases": [{ "hp": 350, "speed": 90, "attack": "clone_self" }, { "hp": 200, "speed": 110, "attack": "directional_wave" }] },
                "cyber_demon": { "id": "cyber_demon", "name": "Cyber Demon", "color": "#39ff14", "radius": 50, "phases": [{ "hp": 380, "speed": 80, "attack": "hacker_blast" }, { "hp": 240, "speed": 95, "attack": "turret_spawn" }] }
            },
            skins: [
                { "id": "default_skin", "name": "Default", "price": 0, "texture": null, "owned": true, "description": "پوسته پیش‌فرض", "ability": { "name": "Default", "description": "بدون توانایی خاص" } },
                { "id": "star_skin", "name": "Star", "price": 400, "texture": null, "owned": false, "description": "یک پوسته ستاره‌ای درخشان", "ability": { "name": "نور ستاره", "description": "سرعت حرکت را ۱۰٪ افزایش می‌دهد." } },
                { "id": "swirl_skin", "name": "Swirl", "price": 700, "texture": null, "owned": false, "description": "پوسته گردباد مرموز", "ability": { "name": "گرداب تاریکی", "description": "قدرت گلوله‌ها را ۱۰٪ افزایش می‌دهد." } },
                { "id": "neon_skin", "name": "Neon", "price": 900, "texture": null, "owned": false, "description": "یک پوسته با نورهای نئون درخشان", "ability": { "name": "انفجار نوری", "description": "شلیک سریع‌تر به مدت کوتاه." } },
                { "id": "gold_skin", "name": "Gold", "price": 1200, "texture": null, "owned": false, "description": "پوسته طلایی براق و سلطنتی", "ability": { "name": "لمس میداس", "description": "توکن‌های بیشتری از دشمنان دریافت می‌کنید." } },
                { "id": "void_skin", "name": "Void", "price": 1500, "texture": null, "owned": false, "description": "پوسته سیاه و خالی از سکنه", "ability": { "name": "سوراخ کرمچاله", "description": "احتمال تله‌پورت دشمنان به مکان‌های تصادفی بیشتر می‌شود." } },
                { "id": "cyber_skin", "name": "Cyber", "price": 1800, "texture": null, "owned": false, "description": "یک پوسته سایبرپانک پیشرفته", "ability": { "name": "هک سیستم", "description": "احتمال اختلال در حرکت دشمنان را افزایش می‌دهد." } }
            ],
            upgrades: [
                { "id": "moveSpeed", "name": "سرعت حرکت", "level": 0, "max": 7, "baseCost": 120, "costMult": 1.7, "description": "سرعت حرکت را افزایش می‌دهد." },
                { "id": "projSpeed", "name": "سرعت گلوله", "level": 0, "max": 6, "baseCost": 140, "costMult": 1.7, "description": "سرعت پرتابه‌ها را افزایش می‌دهد." },
                { "id": "fireRate", "name": "سرعت شلیک", "level": 0, "max": 8, "baseCost": 160, "costMult": 1.75, "description": "سرعت شلیک را افزایش می‌دهد." },
                { "id": "baseDamage", "name": "قدرت گلوله", "level": 0, "max": 5, "baseCost": 200, "costMult": 1.8, "description": "میزان خسارت گلوله‌ها را افزایش می‌دهد." },
                { "id": "shieldTime", "name": "مدت سپر", "level": 0, "max": 6, "baseCost": 190, "costMult": 1.75, "description": "مدت زمان فعال بودن سپر را افزایش می‌دهد." },
                { "id": "shieldCooldown", "name": "کاهش زمان بازیابی سپر", "level": 0, "max": 4, "baseCost": 220, "costMult": 1.8, "description": "زمان بازیابی سپر را کاهش می‌دهد." },
                { "id": "nearMiss", "name": "کمبوی نزدیک", "level": 0, "max": 4, "baseCost": 160, "costMult": 1.7, "description": "ضریب کمبو را برای جاخالی‌های نزدیک افزایش می‌دهد." },
                { "id": "scoreBoost", "name": "افزایش امتیاز", "level": 0, "max": 5, "baseCost": 180, "costMult": 1.75, "description": "امتیاز دریافتی از دشمنان را افزایش می‌دهد." },
                { "id": "tokenBoost", "name": "افزایش توکن", "level": 0, "max": 5, "baseCost": 220, "costMult": 1.8, "description": "تعداد توکن‌های دریافتی را افزایش می‌دهد." },
                { "id": "dropRate", "name": "شانس آیتم", "level": 0, "max": 4, "baseCost": 170, "costMult": 1.7, "description": "شانس افتادن آیتم‌ها را افزایش می‌دهد." },
                { "id": "freezeTime", "name": "قدرت انجماد", "level": 0, "max": 3, "baseCost": 200, "costMult": 1.9, "description": "مدت زمان انجماد دشمنان را افزایش می‌دهد." },
                { "id": "slowMoTime", "name": "مدت اسلوموشن", "level": 0, "max": 3, "baseCost": 200, "costMult": 1.9, "description": "مدت زمان فعال بودن امتیاز دو برابر را افزایش می‌دهد." },
                { "id": "doubleScore", "name": "مدت امتیاز دو برابر", "level": 0, "max": 3, "baseCost": 210, "costMult": 1.9, "description": "مدت زمان فعال بودن امتیاز دو برابر را افزایش می‌دهد." }
            ],
            store: [
                { id: "fireRate", category: "upgrades", type: "permanent" },
                { id: "baseDamage", category: "upgrades", type: "permanent" },
                { id: "moveSpeed", category: "upgrades", type: "permanent" },
                { id: "shield", category: "consumables", type: "consumable" },
                { id: "star_skin", category: "cosmetics", type: "cosmetic" },
                { id: "swirl_skin", category: "cosmetics", type: "cosmetic" },
                { id: "neon_skin", category: "cosmetics", type: "cosmetic" },
                { id: "gold_skin", category: "cosmetics", type: "cosmetic" },
                { id: "void_skin", category: "cosmetics", type: "cosmetic" },
                { id: "cyber_skin", category: "cosmetics", type: "cosmetic" }
            ],
            story: {
                "wave_1": "فاز ۱: سایه‌ها نزدیک می‌شوند. تنها یک راه فرار داری...",
                "wave_5": "آیا آماده‌ای که در این تاریکی پیش بروی؟",
                "wave_10": "فاز ۲: ذهن در حال پیچیدن است. به خودت اعتماد کن.",
                "wave_15": "تو تنها نیستی...",
                "codex_1": { "title": "تولد یک سایه", "text": "من به یاد دارم که... چیزی نبود جز نور. و بعد، یک شکاف. و در آن شکاف، تاریکی..." }
            }
        };

        const newEnemiesData = {
            "enemies": [
                { "id": "chaser", "name": "Chaser", "color": "#4a4a4a", "shape": "circle", "speed": 80, "hp": 20, "spawn_wave": [1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26, 27, 28, 29] },
                { "id": "wanderer", "name": "Wanderer", "color": "#6b6b6b", "shape": "square", "speed": 60, "hp": 30, "spawn_wave": [2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26, 27, 28, 29] },
                { "id": "shooter", "name": "Shooter", "color": "#0000ff", "shape": "triangle", "speed": 80, "hp": 40, "spawn_wave": [3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26, 27, 28, 29] },
                { "id": "shifter", "name": "Shifter", "color": "#ff69b4", "shape": "hexagon", "speed": 100, "hp": 35, "spawn_wave": [4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26, 27, 28, 29] },
                { "id": "bomber", "name": "Bomber", "color": "#ff0000", "shape": "circle", "speed": 80, "hp": 50, "spawn_wave": [5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29] },
                { "id": "teleporter", "name": "Teleporter", "color": "#9400d3", "shape": "diamond", "speed": 80, "hp": 50, "spawn_wave": [6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28] },
                { "id": "hacker", "name": "Hacker", "color": "#39ff14", "shape": "square", "speed": 90, "hp": 70, "spawn_wave": [7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29] },
                { "id": "armored", "name": "Armored", "color": "#a9a9a9", "shape": "hexagon", "speed": 50, "hp": 200, "dr": 0.5, "spawn_wave": [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28] },
                { "id": "splinterer", "name": "Splinterer", "color": "#800080", "shape": "circle", "speed": 70, "hp": 100, "spawn_wave": [9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29] },
                { "id": "patroller", "name": "Patroller", "color": "#b0b0b0", "shape": "square", "speed": 70, "hp": 25, "spawn_wave": [10, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 26, 27, 28, 29] },
                { "id": "laser_shooter", "name": "Laser Shooter", "color": "#ff00ff", "shape": "triangle", "speed": 75, "hp": 45, "spawn_wave": [11, 13, 15, 17, 19, 21, 23, 25, 27, 29] },
                { "id": "freezer", "name": "Freezer", "color": "#00bfff", "shape": "circle", "speed": 60, "hp": 60, "spawn_wave": [12, 14, 16, 18, 20, 22, 24, 26, 28] },
                { "id": "spawner", "name": "Spawner", "color": "#ffff00", "shape": "octagon", "speed": 50, "hp": 150, "spawn_wave": [13, 16, 19, 22, 25, 28] },
                { "id": "ghost", "name": "Ghost", "color": "#ffffff", "shape": "circle", "speed": 110, "hp": 30, "spawn_wave": [14, 17, 20, 23, 26, 29] },
                { "id": "kamikaze", "name": "Kamikaze", "color": "#ff4500", "shape": "triangle", "speed": 150, "hp": 20, "spawn_wave": [15, 18, 21, 24, 27, 29] },
                { "id": "shielded_chaser", "name": "Shielded Chaser", "color": "#c0c0c0", "shape": "circle", "speed": 85, "hp": 40, "spawn_wave": [16, 18, 20, 22, 24, 26, 28] },
                { "id": "acid_spitter", "name": "Acid Spitter", "color": "#00ff7f", "shape": "circle", "speed": 70, "hp": 55, "spawn_wave": [17, 19, 21, 23, 25, 27, 29] },
                { "id": "mine_layer", "name": "Mine Layer", "color": "#5a5a5a", "shape": "square", "speed": 60, "hp": 70, "spawn_wave": [18, 20, 22, 24, 26, 28] },
                { "id": "corruptor", "name": "Corruptor", "color": "#8b0000", "shape": "octagon", "speed": 95, "hp": 80, "spawn_wave": [19, 21, 23, 25, 27, 29] },
                { "id": "teleport_bomber", "name": "Teleport Bomber", "color": "#9932cc", "shape": "circle", "speed": 100, "hp": 60, "spawn_wave": [20, 22, 24, 26, 28] },
                { "id": "pulse_shooter", "name": "Pulse Shooter", "color": "#ff00ff", "shape": "circle", "speed": 85, "hp": 50, "spawn_wave": [21, 23, 25, 27, 29] },
                { "id": "heavy_armored", "name": "Heavy Armored", "color": "#d3d3d3", "shape": "square", "speed": 40, "hp": 250, "dr": 0.7, "spawn_wave": [22, 24, 26, 28] },
                { "id": "mimic", "name": "Mimic", "color": "#ffc0cb", "shape": "circle", "speed": 90, "hp": 75, "spawn_wave": [23, 25, 27, 29] },
                { "id": "phantom_shifter", "name": "Phantom Shifter", "color": "#4b0082", "shape": "hexagon", "speed": 120, "hp": 65, "spawn_wave": [24, 26, 28] },
                { "id": "void_spawner", "name": "Void Spawner", "color": "#000080", "shape": "octagon", "speed": 55, "hp": 200, "spawn_wave": [25, 28] },
                { "id": "swarm_bomber", "name": "Swarm Bomber", "color": "#8b0000", "shape": "circle", "speed": 100, "hp": 40, "spawn_wave": [26, 28] },
                { "id": "hacker_lord", "name": "Hacker Lord", "color": "#32cd32", "shape": "octagon", "speed": 105, "hp": 90, "spawn_wave": [27, 29] },
                { "id": "shadow_titan", "name": "Shadow Titan", "color": "#1c1c1c", "shape": "square", "speed": 70, "hp": 300, "dr": 0.6, "spawn_wave": [28] },
                { "id": "final_boss_minion", "name": "Final Boss Minion", "color": "#6a0dad", "shape": "circle", "speed": 120, "hp": 150, "spawn_wave": [29] },
                { "id": "final_boss_servant", "name": "Final Boss Servant", "color": "#483d8b", "shape": "hexagon", "speed": 130, "hp": 180, "spawn_wave": [29] }
            ]
        };

        let desktopOnlyScreen, splashScreen, mainMenuScreen, settingsScreen, storeScreen, codexScreen, intermissionScreen, gameOverScreen;
        let usernameInput, startButton, storeGrid, dpsMessage, bossHUD, bossHpFill, bossNameDisplay;
        let globalMessageBox, globalMessageText, globalMessageButton;
        let perfButtons = {};
        let accButtons = {};
        let canvas, ctx, hud;
        let gameOverContinueButton;
        let lastComboTime = 0;
        let comboCount = 0;
        let fireSound, explosionSound, bgMusic, bossMusic, uiClickSound, damageSound, playerDeathSound, levelUpSound;

        const level = { width: 4000, height: 3000 };

        let gameState = {
            userProfile: null,
            isGameRunning: false,
            paused: false,
            currentWave: 1,
            score: 0,
            credit: 0,
            shard: 0,
            keys: 0,
            player: null,
            enemies: [],
            bullets: [],
            particles: [],
            upgrades: {},
            skins: {},
            unlockedCodex: [],
            runHistory: [],
            performanceMode: 'medium',
            accessibility: {
                highContrast: false,
                reducedMotion: false
            },
            lastFrameTime: 0,
            fpsHistory: [],
            waveTimer: 90,
            intensity: 0,
            difficultyAdjustment: 0,
            consecutiveFailures: 0,
            keysPressed: {},
            mouseX: 0,
            mouseY: 0,
            mouseButton: -1,
            cameraX: 0,
            cameraY: 0,
            waveStartDelay: 6,
            enemySpawnTimer: 0,
            enemiesToSpawn: [],
            currentBoss: null,
            hackerEffectActive: false,
            hackerEffectTimer: 0,
            isShaking: false,
        };

        const performanceSettings = {
            low: { resolutionScale: 0.75, blur: 0, particleLimit: 50, trailLength: 10, enemyLimit: 1 },
            medium: { resolutionScale: 1, blur: 5, particleLimit: 100, trailLength: 20, enemyLimit: 1 },
            high: { resolutionScale: 1, blur: 10, particleLimit: 200, trailLength: 40, enemyLimit: 1 }
        };

        class Player {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.baseSpeed = 300;
                this.speed = this.baseSpeed;
                this.hp = 100;
                this.maxHp = 100;
                this.baseFireRate = 0.5;
                this.fireRate = this.baseFireRate;
                this.baseDamage = 5;
                this.damage = this.baseDamage;
                this.fireCooldown = 0;
                this.isDashing = false;
                this.dashCooldown = 0;
                this.dashDuration = 0.2;
                this.blinkCooldown = 0;
                this.blinkDistance = 150;
                this.trail = [];
                this.skin = 'default_skin';
                this.hasShield = false;
                this.shieldTime = 0;
            }

            applyUpgrades() {
                const fireRateLevel = gameState.upgrades['fireRate'] || 0;
                const playerSpeedLevel = gameState.upgrades['moveSpeed'] || 0;
                const damageLevel = gameState.upgrades['baseDamage'] || 0;

                this.fireRate = this.baseFireRate * Math.pow(0.85, fireRateLevel);
                this.speed = this.baseSpeed * (1 + 0.1 * playerSpeedLevel);
                this.damage = this.baseDamage + damageLevel * 5;
            }

            activateShield() {
                this.hasShield = true;
                this.shieldTime = 10;
            }

            update(dt) {
                let currentSpeed = this.isDashing ? 1000 : this.speed;
                
                if (gameState.hackerEffectActive) {
                    currentSpeed *= 0.5;
                    gameState.hackerEffectTimer -= dt;
                    if (gameState.hackerEffectTimer <= 0) {
                        gameState.hackerEffectActive = false;
                    }
                }

                if (gameState.keysPressed['w'] || gameState.keysPressed['W'] || gameState.keysPressed['ArrowUp']) this.y -= currentSpeed * dt;
                if (gameState.keysPressed['s'] || gameState.keysPressed['S'] || gameState.keysPressed['ArrowDown']) this.y += currentSpeed * dt;
                if (gameState.keysPressed['a'] || gameState.keysPressed['A'] || gameState.keysPressed['ArrowLeft']) this.x -= currentSpeed * dt;
                if (gameState.keysPressed['d'] || gameState.keysPressed['D'] || gameState.keysPressed['ArrowRight']) this.x += currentSpeed * dt;

                if (gameState.currentWave >= 5 && (gameState.keysPressed['Shift'] || gameState.keysPressed['shift']) && !this.isDashing && this.dashCooldown <= 0) {
                    this.isDashing = true;
                    this.dashCooldown = 2;
                }
                if (this.isDashing) {
                    this.dashDuration -= dt;
                    if (this.dashDuration <= 0) {
                        this.isDashing = false;
                        this.dashDuration = 0.2;
                    }
                }
                this.dashCooldown = Math.max(0, this.dashCooldown - dt);

                if (gameState.currentWave >= 8 && (gameState.keysPressed['b'] || gameState.keysPressed['B']) && this.blinkCooldown <= 0) {
                    const dx = gameState.mouseX - (this.x - gameState.cameraX);
                    const dy = gameState.mouseY - (this.y - gameState.cameraY);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.blinkDistance;
                    this.y += Math.sin(angle) * this.blinkDistance;
                    this.blinkCooldown = 5;
                }
                this.blinkCooldown = Math.max(0, this.blinkCooldown - dt);

                this.fireCooldown = Math.max(0, this.fireCooldown - dt);
                if (gameState.mouseButton === 0 && this.fireCooldown <= 0) {
                    this.fireCooldown = this.fireRate;
                    const targetX = gameState.mouseX;
                    const targetY = gameState.mouseY;
                    gameState.bullets.push(new Projectile(this.x, this.y, 5, "player", "hsl(200, 100%, 70%)", targetX, targetY));
                    if (fireSound) {
                        fireSound.currentTime = 0;
                        fireSound.play();
                    }
                }

                if (this.hasShield) {
                    this.shieldTime -= dt;
                    if (this.shieldTime <= 0) {
                        this.hasShield = false;
                    }
                }

                if (!gameState.accessibility.reducedMotion) {
                    this.trail.push({ x: this.x, y: this.y, size: this.size, opacity: 1 });
                    if (this.trail.length > performanceSettings[gameState.performanceMode].trailLength) {
                        this.trail.shift();
                    }
                }

                this.x = Math.max(this.size, Math.min(level.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(level.height - this.size, this.y));
            }

            draw(ctx, cameraX, cameraY) {
                if (!gameState.accessibility.reducedMotion) {
                    this.trail.forEach((p, i) => {
                        const opacity = i / this.trail.length;
                        ctx.fillStyle = `rgba(80, 227, 255, ${opacity * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(p.x - cameraX, p.y - cameraY, p.size * opacity, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                if (this.hasShield) {
                    const opacity = this.shieldTime > 1 ? 0.5 : this.shieldTime;
                    ctx.fillStyle = `rgba(80, 227, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(this.x - cameraX, this.y - cameraY, this.size + 10, 0, Math.PI * 2);
                    ctx.fill();
                }

                const currentSkin = gameData.skins.find(s => s.id === this.skin);
                ctx.fillStyle = currentSkin ? currentSkin.color : "hsl(200, 100%, 70%)";
                ctx.shadowColor = currentSkin ? currentSkin.color : "hsl(200, 100%, 80%)";
                ctx.shadowBlur = performanceSettings[gameState.performanceMode].blur;

                const shape = currentSkin ? currentSkin.shape : 'circle';
                const playerScreenX = this.x - cameraX;
                const playerScreenY = this.y - cameraY;

                if (shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(playerScreenX, playerScreenY, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (shape === 'arrow') {
                    ctx.save();
                    ctx.translate(playerScreenX, playerScreenY);
                    const angle = Math.atan2(gameState.mouseY - playerScreenY, gameState.mouseX - playerScreenX);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size, this.size);
                    ctx.lineTo(-this.size, this.size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                ctx.shadowBlur = 0;
            }
        }

        class Enemy {
            constructor(data) {
                this.data = data;
                this.x = Math.random() * level.width;
                this.y = Math.random() * level.height;
                
                this.size = 20;
                this.speed = data.speed;
                this.color = data.color;
                this.shape = data.shape;
                
                this.phaseTime = 0;

                const damageLevel = gameState.upgrades['baseDamage'] || 0;
                const baseHpForDifficulty = 10;
                let calculatedHp = Math.round(baseHpForDifficulty * (1 + (gameState.currentWave - 1) * 0.5));
                calculatedHp -= (damageLevel * 5);
                
                if (calculatedHp <= 0) {
                   calculatedHp = 1;
                }
                
                this.hp = calculatedHp;
                this.maxHp = calculatedHp;
                
                this.damage = 1;
                this.isBoss = false;
                this.fireCooldown = 0;
                this.hackerEffectCooldown = 0;
                this.teleportCooldown = 0;
                this.spawnCooldown = 0;
                this.freezeCooldown = 0;
                
                switch (data.id) {
                    case "chaser": case "wanderer": case "patroller": case "shielded_chaser": case "shadow_titan":
                    case "splinterer": case "mimic": case "phantom_shifter": case "corruptor": case "heavy_armored":
                    case "mine_layer": case "swarm_bomber": case "ghost": case "shifter":
                        this.pattern = "seek";
                        this.animPattern = "pulse";
                        break;
                    case "shooter": case "laser_shooter": case "pulse_shooter": case "acid_spitter":
                        this.pattern = "ranged";
                        this.animPattern = "flicker";
                        this.fireRate = 2;
                        break;
                    case "bomber": case "teleport_bomber": case "kamikaze":
                        this.pattern = "bomber";
                        this.animPattern = "wobble";
                        break;
                    case "hacker": case "hacker_lord":
                        this.pattern = "hacker";
                        this.animPattern = "pulse";
                        this.hackerRate = 10;
                        break;
                    case "teleporter":
                        this.pattern = "teleporter";
                        this.animPattern = "pulse";
                        this.teleportCooldown = 5;
                        break;
                    case "spawner": case "void_spawner":
                        this.pattern = "spawner";
                        this.animPattern = "pulse";
                        this.spawnRate = 15;
                        break;
                    case "freezer":
                        this.pattern = "freezer";
                        this.animPattern = "pulse";
                        this.freezeRate = 7;
                        break;
                    default:
                        this.pattern = "seek";
                        this.animPattern = "pulse";
                        break;
                }
            }

            update(dt) {
                this.phaseTime += dt;
                const distToPlayer = Math.sqrt(Math.pow(gameState.player.x - this.x, 2) + Math.pow(gameState.player.y - this.y, 2));

                switch (this.pattern) {
                    case "seek":
                    case "armored":
                        const dx_seek = gameState.player.x - this.x;
                        const dy_seek = gameState.player.y - this.y;
                        const angle_seek = Math.atan2(dy_seek, dx_seek);
                        this.x += this.speed * Math.cos(angle_seek) * dt;
                        this.y += this.speed * Math.sin(angle_seek) * dt;
                        break;
                    case "ranged":
                        if (distToPlayer > 300) {
                            const angle_range = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                            this.x += this.speed * Math.cos(angle_range) * dt;
                            this.y += this.speed * Math.sin(angle_range) * dt;
                        } else {
                            this.fireCooldown -= dt;
                            if (this.fireCooldown <= 0) {
                                const angle_fire = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                                gameState.bullets.push(new Projectile(this.x, this.y, 10, "enemy", this.color, this.x + Math.cos(angle_fire), this.y + Math.sin(angle_fire)));
                                this.fireCooldown = this.fireRate;
                            }
                        }
                        break;
                    case "bomber":
                        if (distToPlayer < 50) {
                            this.hp = 0;
                        } else {
                            const angle_bomb = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                            this.x += this.speed * Math.cos(angle_bomb) * dt;
                            this.y += this.speed * Math.sin(angle_bomb) * dt;
                        }
                        break;
                    case "hacker":
                        this.hackerEffectCooldown -= dt;
                        if (distToPlayer < 400 && this.hackerEffectCooldown <= 0) {
                            gameState.hackerEffectActive = true;
                            gameState.hackerEffectTimer = 3;
                            this.hackerEffectCooldown = this.hackerRate;
                        }
                        break;
                    case "teleporter":
                        this.teleportCooldown -= dt;
                        if (this.teleportCooldown <= 0) {
                             this.x = Math.random() * level.width;
                             this.y = Math.random() * level.height;
                             this.teleportCooldown = 5;
                        }
                        break;
                    case "spawner":
                        this.spawnCooldown -= dt;
                        if (this.spawnCooldown <= 0) {
                             this.spawnCooldown = this.spawnRate;
                        }
                        break;
                    case "freezer":
                         this.freezeCooldown -= dt;
                         if (distToPlayer < 200 && this.freezeCooldown <= 0) {
                             gameState.player.speed *= 0.5;
                             setTimeout(() => { gameState.player.speed = gameState.player.baseSpeed; }, 3000);
                             this.freezeCooldown = this.freezeRate;
                         }
                         const angle_freezer = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                         this.x += this.speed * Math.cos(angle_freezer) * dt;
                         this.y += this.speed * Math.sin(angle_freezer) * dt;
                         break;
                }

                this.x = Math.max(this.size, Math.min(level.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(level.height - this.size, this.y));
            }

            draw(ctx, cameraX, cameraY) {
                let scale = 1;
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                if (this.animPattern === 'pulse') {
                    scale = 1 + 0.1 * Math.sin(this.phaseTime * 5);
                } else if (this.animPattern === 'wobble') {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(0.1 * Math.sin(this.phaseTime * 7));
                    ctx.translate(-screenX, -screenY);
                }
                
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = performanceSettings[gameState.performanceMode].blur;

                const shape = this.shape;
                const halfSize = this.size * scale;
                const roundedRect = (x, y, w, h, r) => {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.arcTo(x + w, y, x + w, y + r, r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
                    ctx.lineTo(x + r, y + h);
                    ctx.arcTo(x, y + h, x, y + h - r, r);
                    ctx.lineTo(x, y + r);
                    ctx.arcTo(x, y, x + r, y, r);
                    ctx.closePath();
                    ctx.fill();
                }

                if (shape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, halfSize, 0, Math.PI * 2);
                    ctx.fill();
                } else if (shape === 'square') {
                    roundedRect(screenX - halfSize, screenY - halfSize, halfSize * 2, halfSize * 2, 5);
                } else if (shape === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - halfSize);
                    ctx.lineTo(screenX + halfSize, screenY + halfSize);
                    ctx.lineTo(screenX - halfSize, screenY + halfSize);
                    ctx.closePath();
                    ctx.fill();
                } else if (shape === 'hexagon') {
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        ctx.lineTo(screenX + halfSize * Math.cos(angle), screenY + halfSize * Math.sin(angle));
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (shape === 'diamond') {
                     ctx.beginPath();
                     ctx.moveTo(screenX, screenY - halfSize);
                     ctx.lineTo(screenX + halfSize, screenY);
                     ctx.lineTo(screenX, screenY + halfSize);
                     ctx.lineTo(screenX - halfSize, screenY);
                     ctx.closePath();
                     ctx.fill();
                } else if (shape === 'octagon') {
                     ctx.beginPath();
                     for (let i = 0; i < 8; i++) {
                         const angle = Math.PI / 4 * i;
                         ctx.lineTo(screenX + halfSize * Math.cos(angle), screenY + halfSize * Math.sin(angle));
                     }
                     ctx.closePath();
                     ctx.fill();
                }

                ctx.shadowBlur = 0;

                const hpPercent = this.hp / this.maxHp;
                ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
                roundedRect(screenX - halfSize, screenY - halfSize - 10, halfSize * 2, 5, 2);
                ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
                roundedRect(screenX - halfSize, screenY - halfSize - 10, halfSize * 2 * hpPercent, 5, 2);

                if (this.animPattern === 'wobble') {
                    ctx.restore();
                }
            }
        }
        
        class Boss {
            constructor(data) {
                this.data = data;
                this.x = level.width / 2;
                this.y = level.height / 2;
                this.isBoss = true;
                this.currentPhaseIndex = 0;
                this.currentPhase = this.data.phases[this.currentPhaseIndex];
                this.hp = this.currentPhase.hp;
                this.maxHp = this.data.phases.reduce((sum, phase) => sum + phase.hp, 0);
                this.totalHp = this.maxHp;
                this.speed = this.currentPhase.speed;
                this.size = this.data.radius;
                this.color = this.data.color;
                this.attackCooldown = 0;
                this.attackTimer = 0;
                this.phaseTime = 0;
            }

            update(dt) {
                this.phaseTime += dt;
                
                const totalHpRemaining = gameState.enemies.reduce((sum, enemy) => sum + enemy.hp, 0);
                if (this.currentPhaseIndex < this.data.phases.length - 1) {
                    const nextPhaseHpThreshold = this.totalHp - this.data.phases.slice(0, this.currentPhaseIndex + 1).reduce((sum, phase) => sum + phase.hp, 0);
                    if (totalHpRemaining <= nextPhaseHpThreshold) {
                        this.currentPhaseIndex++;
                        this.currentPhase = this.data.phases[this.currentPhaseIndex];
                        this.speed = this.currentPhase.speed;
                        showMessageBox(`باس وارد فاز ${this.currentPhaseIndex + 1} شد!`);
                    }
                }
                
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 100) {
                    this.x += (dx / distance) * this.speed * dt;
                    this.y += (dy / distance) * this.speed * dt;
                }
                
                this.attackTimer -= dt;
                if (this.attackTimer <= 0) {
                    this.performAttack();
                    this.attackTimer = 3;
                }
            }

            performAttack() {
                switch (this.currentPhase.attack) {
                    case "charge_player":
                        break;
                    case "spawn_bullets":
                        break;
                    case "spawn_minions":
                        break;
                    case "laser_beam":
                        break;
                    case "teleport_and_shoot":
                        break;
                    case "shockwave":
                        break;
                    case "teleport_and_stomp":
                        break;
                    case "slow_meteor":
                        break;
                    case "spawn_bombers":
                        break;
                    case "rapid_shot":
                        break;
                    case "clone_self":
                        break;
                    case "directional_wave":
                        break;
                    case "hacker_blast":
                        break;
                    case "turret_spawn":
                        break;
                    default:
                        break;
                }
            }
            
            draw(ctx, cameraX, cameraY) {
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;

                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = performanceSettings[gameState.performanceMode].blur;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Projectile {
            constructor(x, y, size, type, color, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.speed = 800;
                this.type = type;
                this.color = color;

                const dx = targetX - (this.x - gameState.cameraX);
                const dy = targetY - (this.y - gameState.cameraY);
                const angle = Math.atan2(dy, dx);
                this.vx = this.speed * Math.cos(angle);
                this.vy = this.speed * Math.sin(angle);
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }

            draw(ctx, cameraX, cameraY) {
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = performanceSettings[gameState.performanceMode].blur;
                ctx.beginPath();
                ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color, size, speedX, speedY, decay) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.speedX = speedX;
                this.speedY = speedY;
                this.decay = decay;
                this.opacity = 1;
            }

            update(dt) {
                this.x += this.speedX;
                this.y += this.speedY;
                this.size -= this.decay * dt;
                this.opacity -= this.decay * dt;
            }

            draw(ctx, cameraX, cameraY) {
                if (this.size <= 0) return;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function showScreen(screenId) {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => screen.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) {
                screenToShow.classList.add('active');
            }
            if (screenId === 'game-hud') {
                hud.style.display = 'flex';
                bossHUD.style.display = 'none';
            } else if (screenId === 'boss-wave') {
                hud.style.display = 'flex';
                bossHUD.style.display = 'flex';
            } else {
                hud.style.display = 'none';
                bossHUD.style.display = 'none';
            }
        }

        function showMessageBox(message) {
            globalMessageText.textContent = message;
            globalMessageBox.style.display = 'flex';
            gameState.paused = true;
        }

        function hideMessageBox() {
            globalMessageBox.style.display = 'none';
            gameState.paused = false;
        }
        
        const saveGame = (profileData) => {
            if (!profileData || !profileData.username) return;
            try {
                localStorage.setItem('shadowScapeProfile_' + profileData.username, JSON.stringify(profileData));
            } catch (e) {
                console.error("Failed to save game state:", e);
                showMessageBox("خطا در ذخیره بازی. ممکن است مرورگر شما از localStorage پشتیبانی نکند.");
            }
        };

        const loadGame = (username) => {
            try {
                const savedProfile = localStorage.getItem('shadowScapeProfile_' + username);
                if (savedProfile) {
                    const profile = JSON.parse(savedProfile);
                    gameState.userProfile = profile;
                    gameState.currentWave = profile.progress.wave;
                    gameState.score = profile.progress.score;
                    gameState.credit = profile.progress.credit;
                    gameState.shard = profile.progress.shard;
                    gameState.keys = profile.progress.keys;
                    gameState.upgrades = profile.upgrades;
                    gameState.skins = profile.skins;
                    gameState.unlockedCodex = profile.unlockedCodex;
                    gameState.runHistory = profile.runHistory;
                    gameState.performanceMode = profile.settings.performanceMode;
                    gameState.accessibility = profile.settings.accessibility;
                    return true;
                }
            } catch (e) {
                console.error("Failed to load game state:", e);
            }
            return false;
        };

        const initGame = () => {
            desktopOnlyScreen = document.getElementById('desktop-only-screen');
            splashScreen = document.getElementById('splash-screen');
            mainMenuScreen = document.getElementById('main-menu-screen');
            settingsScreen = document.getElementById('settings-screen');
            storeScreen = document.getElementById('store-screen');
            codexScreen = document.getElementById('codex-screen');
            intermissionScreen = document.getElementById('wave-intermission-screen');
            gameOverScreen = document.getElementById('game-over-screen');
            usernameInput = document.getElementById('username-input');
            startButton = document.getElementById('start-button');
            storeGrid = document.getElementById('store-grid');
            perfButtons = {
                low: document.getElementById('perf-low'),
                medium: document.getElementById('perf-medium'),
                high: document.getElementById('perf-high')
            };
            accButtons = {
                contrast: document.getElementById('acc-contrast'),
                motion: document.getElementById('acc-motion')
            };
            dpsMessage = document.getElementById('dps-message');
            globalMessageBox = document.getElementById('global-message-box');
            globalMessageText = document.getElementById('global-message-text');
            globalMessageButton = document.getElementById('global-message-button');
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            hud = document.getElementById('game-hud');
            bossHUD = document.getElementById('boss-hud');
            bossHpFill = document.getElementById('boss-hp-fill');
            bossNameDisplay = document.getElementById('boss-name');
            gameOverContinueButton = document.getElementById('game-over-continue');

            // Sound elements
            fireSound = document.getElementById('fire-sound');
            explosionSound = document.getElementById('explosion-sound');
            bgMusic = document.getElementById('background-music');
            bossMusic = document.getElementById('boss-music');
            uiClickSound = document.getElementById('ui-click');
            damageSound = document.getElementById('damage-sound');
            playerDeathSound = document.getElementById('player-death');
            levelUpSound = document.getElementById('level-up');


            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            checkPlatform();

            const savedUsername = localStorage.getItem('shadowScapeUsername');
            if (savedUsername) {
                gameState.userProfile = { username: savedUsername };
                loadGame(savedUsername);
                showScreen('main-menu-screen');
                document.getElementById('continue-game-button').style.display = (gameState.userProfile && gameState.userProfile.progress.wave > 1) ? 'block' : 'none';
            } else {
                showScreen('splash-screen');
            }

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouseX = e.clientX - rect.left;
                gameState.mouseY = e.clientY - rect.top;
            });
            canvas.addEventListener('mousedown', (e) => { if (e.button === 0) gameState.mouseButton = 0; });
            canvas.addEventListener('mouseup', (e) => { if (e.button === 0) gameState.mouseButton = -1; });
        };

        const checkPlatform = () => {
            const isDesktop = window.innerWidth >= 1024 && !/Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isDesktop) {
                showScreen('desktop-only-screen');
                return false;
            }
            return true;
        };

        const newGame = () => {
            gameState.currentWave = 1;
            gameState.score = 0;
            gameState.credit = 0;
            gameState.shard = 0;
            gameState.keys = 0;
            gameState.enemies = [];
            gameState.bullets = [];
            gameState.particles = [];
            gameState.player = new Player(level.width / 2, level.height / 2, 15);
            gameData.upgrades.forEach(u => gameState.upgrades[u.id] = 0);
            gameData.skins.forEach(s => gameState.skins[s.id] = s.owned);
            gameState.player.applyUpgrades();
            gameState.consecutiveFailures = 0;
            gameState.waveTimer = 90;
            gameState.waveStartDelay = 6;
            gameState.enemySpawnTimer = 0;
            gameState.enemiesToSpawn = [];
            gameState.currentBoss = null;
            gameState.hackerEffectActive = false;
            gameState.hackerEffectTimer = 0;
        };

        const startGame = () => {
            showScreen('game-hud');
            hud.style.display = 'flex';
            gameState.isGameRunning = true;
            gameState.paused = false;

            if (!gameState.player) {
                 gameState.player = new Player(level.width / 2, level.height / 2, 15);
            }
            gameState.player.applyUpgrades();
            
            if (bgMusic) bgMusic.play();
            if (bossMusic) bossMusic.pause();

            startWave();
            gameLoop(0);
        };

        const continueGame = () => {
            if (gameState.keys > 0) {
                 gameState.keys--;
                 gameState.player.hp = gameState.player.maxHp;
                 startGame();
            } else {
                 showMessageBox('Key کافی ندارید.');
                 gameOverContinueButton.style.display = 'none';
            }
        };

        const startWave = () => {
            if (gameState.currentWave > 29) {
                 showIntermission();
                 return;
            }

            gameState.enemies = [];
            gameState.bullets = [];
            gameState.waveStartDelay = 6;
            gameState.enemySpawnTimer = 0;
            gameState.currentBoss = null;

            if (gameState.currentWave % 5 === 0) {
                const bossIds = Object.keys(gameData.bosses);
                const randomBossId = bossIds[Math.floor(Math.random() * bossIds.length)];
                const bossData = gameData.bosses[randomBossId];
                gameState.currentBoss = new Boss(bossData);
                gameState.enemies.push(gameState.currentBoss);
                bossNameDisplay.textContent = gameState.currentBoss.data.name;
                bossHpFill.style.backgroundColor = gameState.currentBoss.data.color;
                bossHpFill.style.width = '100%';
                showScreen('boss-wave');
                if (bgMusic) bgMusic.pause();
                if (bossMusic) bossMusic.play();
            } else {
                const enemiesForCurrentWave = newEnemiesData.enemies.filter(enemyData =>
                    enemyData.spawn_wave.includes(gameState.currentWave)
                );

                gameState.enemiesToSpawn = [];
                const totalEnemiesToSpawn = 15;
                if (enemiesForCurrentWave.length > 0) {
                    for (let i = 0; i < totalEnemiesToSpawn; i++) {
                        const randomEnemyData = enemiesForCurrentWave[Math.floor(Math.random() * enemiesForCurrentWave.length)];
                        gameState.enemiesToSpawn.push(randomEnemyData.id);
                    }
                }
                showScreen('game-hud');
            }
            
            gameState.mouseX = canvas.width / 2;
            gameState.mouseY = canvas.height / 2;
            gameState.waveTimer = 90;
        };

        const updateHUD = () => {
            document.getElementById('hud-wave').textContent = gameState.currentWave;
            document.getElementById('hud-hp').textContent = Math.max(0, Math.round(gameState.player.hp));
            document.getElementById('hud-score').textContent = gameState.score;
            document.getElementById('hud-credit').textContent = gameState.credit;
            document.getElementById('hud-keys').textContent = gameState.keys;
            document.getElementById('hud-timer').textContent = Math.max(0, Math.round(gameState.waveTimer));
            
            if (gameState.currentBoss) {
                const bossHpPercent = (gameState.currentBoss.hp / gameState.currentBoss.totalHp) * 100;
                bossHpFill.style.width = `${bossHpPercent}%`;
            }
        };

        const showGameOver = () => {
            gameState.isGameRunning = false;
            document.getElementById('final-score').textContent = gameState.score;
            if (gameState.keys > 0) {
                 gameOverContinueButton.style.display = 'block';
            } else {
                 gameOverContinueButton.style.display = 'none';
            }
            showScreen('game-over-screen');
            gameState.consecutiveFailures++;
            gameState.runHistory.push({ wave: gameState.currentWave, score: gameState.score, timestamp: new Date().toISOString() });
            if (playerDeathSound) playerDeathSound.play();
            saveGame(gameState.userProfile);
        };

        const showIntermission = () => {
            gameState.isGameRunning = false;
            showScreen('wave-intermission-screen');
            const waveStory = (gameData.story && gameData.story['wave_' + gameState.currentWave]) ? gameData.story['wave_' + gameState.currentWave] : "موج تمام شد. نفسی تازه کن.";
            document.getElementById('intermission-message').textContent = waveStory;
            
            const tokensEarned = Math.floor(Math.random() * 6) + 10;
            gameState.credit += tokensEarned;
            
            if (gameState.currentBoss) {
                 gameState.keys++;
                 if (levelUpSound) levelUpSound.play();
                 showMessageBox(`شما ${tokensEarned} توکن و یک Key پاداش گرفتید!`);
            } else {
                 showMessageBox(`شما ${tokensEarned} توکن پاداش گرفتید!`);
            }

            gameState.difficultyAdjustment = 0;
            if (bgMusic) bgMusic.pause();
            if (bossMusic) bossMusic.pause();
            saveGame(gameState.userProfile);
        };

        const drawBackground = (ctx, cameraX, cameraY) => {
            const drawLayer = (color, opacity, offset, speed) => {
                ctx.fillStyle = color;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(0, level.height * 0.7);
                ctx.bezierCurveTo(
                    level.width * 0.25, level.height * 0.5 + offset * 0.5,
                    level.width * 0.75, level.height * 0.8 + offset * 0.5,
                    level.width, level.height * 0.7
                );
                ctx.lineTo(level.width, level.height);
                ctx.lineTo(0, level.height);
                ctx.closePath();
                ctx.fill();
            };

            const parallaxOffset = (level.width * 0.5 - cameraX) * 0.05;
            drawLayer('hsl(240, 20%, 15%)', 0.8, -parallaxOffset * 0.5);
            drawLayer('hsl(240, 20%, 20%)', 0.6, parallaxOffset * 0.5);

            const wave = gameState.currentWave;
            const hue = (wave % 50) * 360 / 50;
            const saturation = (wave % 10) === 0 ? 80 : 50;
            const color = `hsl(${hue}, ${saturation}%, 20%)`;

            ctx.globalAlpha = 0.1;
            ctx.lineWidth = 1;
            ctx.strokeStyle = `hsl(${hue}, ${saturation}%, 40%)`;

            const gridSize = 100;
            const offset = (gameState.lastFrameTime % (gridSize * 2)) / 2;

            ctx.beginPath();
            for (let x = -cameraX % gridSize; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = -cameraY % gridSize; y < canvas.height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        };

        const getUpgradeData = (id) => gameData.upgrades.find(u => u.id === id);
        const getSkinData = (id) => gameData.skins.find(s => s.id === id);

        const updateStore = () => {
            storeGrid.innerHTML = '';
            gameData.upgrades.forEach(upgrade => {
                const upgradeLevel = gameState.upgrades[upgrade.id] || 0;
                const cost = Math.round(upgrade.baseCost * Math.pow(upgrade.costMult, upgradeLevel));
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('store-item');
                itemDiv.innerHTML = `
                    <h3>${upgrade.name} (سطح ${upgradeLevel} / ${upgrade.max})</h3>
                    <p>هزینه: ${cost} اعتبار</p>
                    <p class="ui-text small">${upgrade.description}</p>
                `;
                itemDiv.addEventListener('click', () => {
                    if (uiClickSound) {
                        uiClickSound.currentTime = 0;
                        uiClickSound.play();
                    }
                    if (gameState.credit >= cost && upgradeLevel < upgrade.max) {
                        gameState.credit -= cost;
                        gameState.upgrades[upgrade.id] = upgradeLevel + 1;
                        gameState.player.applyUpgrades();
                        updateStore();
                        saveGame(gameState.userProfile);
                    } else if (upgradeLevel >= upgrade.max) {
                         showMessageBox('این ارتقاء به حداکثر سطح خود رسیده است.');
                    } else {
                        showMessageBox('اعتبار کافی ندارید.');
                    }
                });
                storeGrid.appendChild(itemDiv);
            });
            gameData.skins.forEach(skin => {
                const isOwned = gameState.skins[skin.id];
                const skinCost = skin.price || 0;
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('store-item');
                itemDiv.innerHTML = `
                    <h3>${skin.name}</h3>
                    <p>هزینه: ${skinCost} اعتبار</p>
                    <p class="ui-text small">${skin.description}</p>
                    ${isOwned ? '<p><b>(خریداری شده)</b></p>' : ''}
                `;
                itemDiv.addEventListener('click', () => {
                    if (uiClickSound) {
                        uiClickSound.currentTime = 0;
                        uiClickSound.play();
                    }
                    if (isOwned) {
                        gameState.player.skin = skin.id;
                        showMessageBox(`پوسته ${skin.name} فعال شد!`);
                        saveGame(gameState.userProfile);
                        return;
                    }
                    if (gameState.credit >= skinCost) {
                        gameState.credit -= skinCost;
                        gameState.skins[skin.id] = true;
                        gameState.player.skin = skin.id;
                        updateStore();
                        showMessageBox(`پوسته ${skin.name} خریداری و فعال شد!`);
                        saveGame(gameState.userProfile);
                    } else {
                        showMessageBox('اعتبار کافی ندارید.');
                    }
                });
                storeGrid.appendChild(itemDiv);
            });
            
            document.getElementById('credit-display').textContent = gameState.credit;
            document.getElementById('shard-display').textContent = gameState.shard;
        };

        const updateCodex = () => {
            const codexEntries = document.getElementById('codex-entries');
            codexEntries.innerHTML = '';

            const staticEntry = document.createElement('div');
            staticEntry.classList.add('codex-entry');
            const codex_1 = gameData.story ? gameData.story.codex_1 : null;
            if (codex_1) {
                staticEntry.innerHTML = `<h3>${codex_1.title}</h3><p>${codex_1.text}</p>`;
            }
            codexEntries.appendChild(staticEntry);

            gameState.unlockedCodex.forEach(bossId => {
                const bossData = gameData.bosses[bossId];
                if (bossData) {
                    const bossEntry = document.createElement('div');
                    bossEntry.classList.add('codex-entry');
                    bossEntry.innerHTML = `<h3>${bossData.name}</h3>
                                           <p><strong>ورود:</strong> ${bossData.dialogue.entry}</p>
                                           <p><strong>نیمه‌جان:</strong> ${bossData.dialogue.half}</p>
                                           <p><strong>شکست:</strong> ${bossData.dialogue.death}</p>`;
                    codexEntries.appendChild(bossEntry);
                }
            });
        };

        const updateSettingsUI = () => {
            Object.values(perfButtons).forEach(btn => btn.classList.remove('selected'));
            if (perfButtons[gameState.performanceMode]) {
                 perfButtons[gameState.performanceMode].classList.add('selected');
            }

            accButtons.contrast.classList.toggle('selected', gameState.accessibility.highContrast);
            accButtons.motion.classList.toggle('selected', gameState.accessibility.reducedMotion);

            if (gameState.accessibility.highContrast) {
                document.body.style.filter = 'grayscale(100%)';
            } else {
                document.body.style.filter = 'none';
            }
        };

        const setupEventListeners = () => {
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                checkPlatform();
            });

            document.getElementById('start-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                const username = document.getElementById('username-input').value.trim();
                if (username.length > 2) {
                    localStorage.setItem('shadowScapeUsername', username);
                    const profileData = { username: username, progress: { wave: 1, score: 0, credit: 0, shard: 0, keys: 0 }, upgrades: {}, skins: { 'default_skin': true }, unlockedCodex: [], runHistory: [], settings: { performanceMode: 'medium', accessibility: { highContrast: false, reducedMotion: false } } };
                    gameData.upgrades.forEach(u => profileData.upgrades[u.id] = 0);
                    gameData.skins.forEach(s => profileData.skins[s.id] = s.owned);
                    saveGame(profileData);
                    gameState.userProfile = profileData;
                    showScreen('main-menu-screen');
                    document.getElementById('continue-game-button').style.display = 'none';
                } else {
                    showMessageBox('لطفا یک نام کاربری معتبر وارد کنید.');
                }
            });

            document.getElementById('start-game-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                newGame();
                startGame();
            });

            document.getElementById('continue-game-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                startGame();
            });

            document.getElementById('game-over-restart').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                newGame();
                startGame();
            });
            
            document.getElementById('game-over-continue').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                 continueGame();
            });

            document.getElementById('game-over-menu').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                showScreen('main-menu-screen');
            });

            document.getElementById('store-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                updateStore();
                showScreen('store-screen');
            });

            document.getElementById('codex-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                updateCodex();
                showScreen('codex-screen');
            });

            document.getElementById('settings-button').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
                showScreen('settings-screen');
            });

            document.getElementById('back-to-menu-from-settings').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                showScreen('main-menu-screen');
            });

            document.getElementById('back-to-menu-from-store').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                showScreen('main-menu-screen');
            });

            document.getElementById('back-to-menu-from-codex').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                showScreen('main-menu-screen');
            });

            document.getElementById('intermission-continue').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.currentWave++;
                startWave();
                startGame();
            });

            document.getElementById('intermission-store').addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                updateStore();
                showScreen('store-screen');
            });

            document.getElementById('global-message-button').addEventListener('click', () => hideMessageBox());

            perfButtons.low.addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.performanceMode = 'low';
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
            });
            perfButtons.medium.addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.performanceMode = 'medium';
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
            });
            perfButtons.high.addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.performanceMode = 'high';
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
            });

            accButtons.contrast.addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.accessibility.highContrast = !gameState.accessibility.highContrast;
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
            });
            accButtons.motion.addEventListener('click', () => {
                if (uiClickSound) {
                    uiClickSound.currentTime = 0;
                    uiClickSound.play();
                }
                gameState.accessibility.reducedMotion = !gameState.accessibility.reducedMotion;
                updateSettingsUI();
                if (gameState.userProfile) saveGame(gameState.userProfile);
            });

            window.addEventListener('keydown', (e) => {
                gameState.keysPressed[e.key] = true;
                if (e.key === 'p' || e.key === 'P') {
                    gameState.paused = !gameState.paused;
                    if(gameState.paused) { showMessageBox('بازی متوقف شد.'); } else { hideMessageBox(); }
                }
            });
            window.addEventListener('keyup', (e) => {
                gameState.keysPressed[e.key] = false;
            });
        };

        const gameLoop = (timestamp) => {
            if (!gameState.isGameRunning || gameState.paused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const dt = (timestamp - gameState.lastFrameTime) / 1000;
            gameState.lastFrameTime = timestamp;
            
            let shakeX = 0;
            let shakeY = 0;
            if (gameState.isShaking) {
                shakeX = (Math.random() - 0.5) * 10;
                shakeY = (Math.random() - 0.5) * 10;
                gameState.isShaking = false;
            }
            
            if (gameState.currentWave % 5 !== 0) {
                gameState.waveStartDelay = Math.max(0, gameState.waveStartDelay - dt);
                if (gameState.waveStartDelay <= 0) {
                    gameState.enemySpawnTimer -= dt;
                    if (gameState.enemiesToSpawn.length > 0 && gameState.enemySpawnTimer <= 0) {
                        const nextEnemyId = gameState.enemiesToSpawn.shift();
                        const enemyData = newEnemiesData.enemies.find(e => e.id === nextEnemyId);
                        if (enemyData) {
                            gameState.enemies.push(new Enemy(enemyData));
                        }
                        gameState.enemySpawnTimer = 0.5;
                    }
                }
            }
            
            gameState.waveTimer -= dt;
            if (gameState.waveTimer <= 0) {
                 if (gameState.currentWave > 29) {
                     showMessageBox("شما بازی را به پایان رساندید!");
                     return;
                 }
                 gameState.enemies = [];
                 showIntermission();
                 return;
            }
            
            if (gameState.currentBoss) {
                 if (gameState.currentBoss.hp <= 0) {
                     gameState.score += 500;
                     showMessageBox(`${gameState.currentBoss.data.name} شکست خورد!`);
                     gameState.enemies = [];
                     gameState.currentWave++;
                     showIntermission();
                     return;
                 }
            }

            gameState.player.update(dt);
            gameState.enemies = gameState.enemies.filter(e => e.hp > 0);
            gameState.enemies.forEach(e => e.update(dt));
            gameState.bullets = gameState.bullets.filter(b => {
                const onScreen = b.x > -50 && b.x < level.width + 50 && b.y > -50 && b.y < level.height + 50;
                return onScreen;
            });
            gameState.particles = gameState.particles.filter(p => p.size > 0);
            gameState.bullets.forEach(b => b.update(dt));
            gameState.particles.forEach(p => p.update(dt));

            gameState.cameraX = gameState.player.x - canvas.width / 2;
            gameState.cameraY = gameState.player.y - canvas.height / 2;
            gameState.cameraX = Math.max(0, Math.min(level.width - canvas.width, gameState.cameraX));
            gameState.cameraY = Math.max(0, Math.min(level.height - canvas.height, gameState.cameraY));

            gameState.enemies.forEach((enemy, enemyIndex) => {
                const distance = Math.sqrt(Math.pow(enemy.x - gameState.player.x, 2) + Math.pow(enemy.y - gameState.player.y, 2));
                if (distance < enemy.size + gameState.player.size) {
                    if (!gameState.player.hasShield) {
                        gameState.player.hp -= enemy.damage;
                        if (damageSound) {
                            damageSound.currentTime = 0;
                            damageSound.play();
                        }
                        if (gameState.player.hp <= 0) {
                            showGameOver();
                        } else {
                            gameState.isShaking = true;
                        }
                    }
                }

                gameState.bullets.forEach((bullet, bulletIndex) => {
                    const bulletDistance = Math.sqrt(Math.pow(bullet.x - enemy.x, 2) + Math.pow(bullet.y - enemy.y, 2));
                    if (bullet.type === 'player' && bulletDistance < enemy.size + bullet.size) {
                        let damageDealt = gameState.player.damage;
                        if (enemy.data.dr) {
                             damageDealt *= (1 - enemy.data.dr);
                        }
                        enemy.hp -= damageDealt;
                        gameState.bullets.splice(bulletIndex, 1);
                        if (enemy.hp <= 0) {
                            if (explosionSound) {
                                explosionSound.currentTime = 0;
                                explosionSound.play();
                            }
                            if (enemy.isBoss) {
                                gameState.keys++;
                                enemy.hp = 0;
                            } else {
                                gameState.score += 10;
                            }

                            if (!gameState.accessibility.reducedMotion) {
                                for (let i = 0; i < performanceSettings[gameState.performanceMode].particleLimit / 10; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = Math.random() * 2 + 1;
                                    gameState.particles.push(new Particle(enemy.x, enemy.y, "white", 5, Math.cos(angle) * speed, Math.sin(angle) * speed, 0.05));
                                }
                            }
                            if (!enemy.isBoss) {
                                gameState.enemies.splice(enemyIndex, 1);
                            }
                        }
                    }
                });
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const scaleFactor = performanceSettings[gameState.performanceMode].resolutionScale;
            ctx.save();
            ctx.scale(scaleFactor, scaleFactor);
            ctx.translate(shakeX, shakeY);

            drawBackground(ctx, gameState.cameraX, gameState.cameraY);
            gameState.particles.forEach(p => p.draw(ctx, gameState.cameraX, gameState.cameraY));
            gameState.player.draw(ctx, gameState.cameraX, gameState.cameraY);
            gameState.enemies.forEach(e => e.draw(ctx, gameState.cameraX, gameState.cameraY));
            gameState.bullets.forEach(b => b.draw(ctx, gameState.cameraX, gameState.cameraY));

            ctx.restore();
            updateHUD();

            requestAnimationFrame(gameLoop);
        };

        window.onload = () => {
            initGame();
            setupEventListeners();
        };

    </script>
</body>
</html>
