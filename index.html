<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Escape</title>
    <style>
        /* General Styles for the body */
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0d0d0d;
            color: #f0f0f0;
            font-family: 'Vazirmatn', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            text-align: center;
            transition: background-color 0.5s;
        }

        /* Mobile Device Restriction Overlay */
        #mobile-restriction {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        
        #mobile-restriction h1 {
            font-size: 2rem;
            color: #ffcc00;
            margin-bottom: 10px;
        }

        #mobile-restriction p {
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        /* Game Container */
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0a0a0a;
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 90vh;
            aspect-ratio: 4/3;
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            background: linear-gradient(180deg, rgba(26,26,26,0.95), rgba(14,14,14,0.95));
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            transition: transform .15s ease, box-shadow .15s ease, border-color .2s ease;
            opacity: 0;
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 80%;
            max-width: 400px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .ui-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .ui-panel.half-visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
            max-width: 100%;
        }

        .ui-panel h1, .ui-panel h2 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 15px #ffcc00;
        }

        .ui-panel p {
            font-size: 1.1rem;
            margin: 0 0 20px 0;
            line-height: 1.6;
            color: #ccc;
        }

        /* Buttons */
        .button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            border: none;
            border-radius: 12px;
            background: linear-gradient(145deg, #1f1f1f, #2a2a2a);
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
            transition: all 0.2s ease;
            user-select: none;
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInUp 0.5s forwards;
            letter-spacing: .3px;
        }
        
        .ui-panel button:nth-child(1) { animation-delay: 0.2s; }
        .ui-panel button:nth-child(2) { animation-delay: 0.4s; }
        .ui-panel button:nth-child(3) { animation-delay: 0.6s; }
        .ui-panel button:nth-child(4) { animation-delay: 0.8s; }
        .ui-panel button:nth-child(5) { animation-delay: 1.0s; }
        .ui-panel button:nth-child(6) { animation-delay: 1.2s; }
        
        @keyframes fadeInUp {
            to { opacity: 1; transform: scale(1); }
        }

        .button:hover {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            transform: translateY(-4px);
            box-shadow: 0 14px 40px rgba(0,0,0,0.6);
            border-color: rgba(255,255,255,0.16);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
        }

        .button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Shop & Upgrade Items */
        .upgrade-card, .shop-item, .mission-item {
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            background: linear-gradient(180deg, rgba(26,26,26,0.95), rgba(14,14,14,0.95));
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            transition: transform .15s ease, box-shadow .15s ease, border-color .2s ease;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            text-align: right;
            position: relative;
        }
        
        .shop-item:hover, .upgrade-card:hover, .mission-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 14px 40px rgba(0,0,0,0.6);
            border-color: rgba(255,255,255,0.16);
        }
        
        .upgrade-card h3, .shop-item h3, .mission-item h3 {
            margin: 0 0 5px 0;
            color: #f0f0f0;
            font-size: 1.2rem;
        }

        .upgrade-card p, .shop-item p, .mission-item p {
            margin: 0;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .shop-item.purchased {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .shop-item.active {
            border-color: #ffcc00;
        }

        .shop-item .price, .mission-item .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #fff;
        }

        .shop-item .level {
            display: block;
            margin-top: 5px;
            font-size: 0.8rem;
            color: #888;
        }

        /* HUD */
        #hud-container {
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            width: 100%;
            position: absolute;
            top: 20px;
            left: 0;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            width: 100%;
            max-width: 800px;
            padding: 0 20px;
        }

        #hud > div {
            border-radius: 10px;
            border: 1px solid var(--hud-accent, rgba(255,255,255,0.07));
            background: rgba(0,0,0,0.35);
            backdrop-filter: blur(5px);
            padding: 8px 15px;
            font-weight: bold;
            font-size: 1rem;
        }

        #hud-left, #hud-right {
            display: flex;
            gap: 10px;
        }
        
        #hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        #wave-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #wave-timer {
            font-size: 1.2rem;
            font-weight: bold;
        }

        #shield-bar {
            width: 100px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-right: 5px;
        }

        #shield-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffff);
            transition: width 0.1s linear;
        }

        #boss-health-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid #ff0000;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 50;
        }

        #boss-health-progress {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6347);
        }

        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #ffcc00;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #audio-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            color: #fff;
            text-shadow: 0 0 5px #fff;
        }

        /* Custom message box outside the game */
        #message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: right;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            max-width: 300px;
        }

        #message-box.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Loading Overlay - REMOVED */
        
        #shootBtn {
          position: absolute;
          bottom: 20px;
          right: 20px;
          padding: 10px 20px;
          font-size: 18px;
          cursor: pointer;
          z-index: 100;
          background: linear-gradient(45deg, #00aaff, #00ffff);
          color: #1a1a1a;
          border: none;
          border-radius: 10px;
          box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
          transition: all 0.2s ease;
          font-weight: bold;
          display: none;
        }
        
        #shootBtn:hover {
            transform: scale(1.1);
        }
        
        #shootBtn:active {
            transform: scale(0.95);
        }
        
        /* Responsive styles for mobile */
        @media (max-width: 600px) {
            #game-container {
                max-width: 98vw;
                max-height: 98vh;
            }
            .ui-panel {
                width: 90%;
                max-width: 300px;
            }
            .ui-panel h1, .ui-panel h2 {
                font-size: 1.8rem;
            }
            .ui-panel p {
                font-size: 1rem;
            }
            .button {
                font-size: 1rem;
                padding: 12px;
                margin: 10px 0;
            }
            #hud {
                top: 10px;
                left: 10px;
                right: 10px;
                font-size: 0.8rem;
            }
            #hud > div {
                padding: 6px 10px;
            }
            #shield-bar {
                width: 70px;
            }
            #combo-display {
                font-size: 2rem;
            }
            
            #audio-toggle {
                bottom: 20px;
                left: 20px;
            }

            #shootBtn {
                display: block;
                bottom: 20px;
                right: 20px;
                transform: translateX(0);
                font-size: 1rem;
                padding: 10px 15px;
            }

            /* Hide game container on mobile */
            #game-container {
                display: none;
            }
            
            #mobile-restriction {
                display: flex;
            }
        }

        /* Desktop specific styles */
        @media (min-width: 601px) {
            #mobile-restriction {
                display: none;
            }
            #game-container {
                display: block;
            }
        }
        
        .mission-item.completed {
            background: rgba(0, 100, 0, 0.9);
            border-color: #00ff00;
            color: #fff;
        }

        #missions-menu, #shop-menu, #character-menu, #skins-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #missions-list, #shop-items, #character-options, #skins-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            width: 100%;
        }

        @media (min-width: 600px) {
            #missions-list, #shop-items, #character-options, #skins-options {
                grid-template-columns: repeat(9, 1fr);
                gap: 20px;
            }
        }

        #shop-menu .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 2rem;
            color: #ff0000;
            cursor: pointer;
        }

        .token-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            font-size: 1em;
            color: #ff0000;
            text-shadow: 0 0 5px #ff6347;
            vertical-align: middle;
            margin-left: 5px;
        }

        .token-icon-hud {
            color: #ff0000;
            text-shadow: 0 0 5px #ff6347;
        }

        /* New styles for shop item layout */
        #shop-items {
            grid-template-columns: repeat(9, 1fr);
            gap: 20px;
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <div id="mobile-restriction">
        <h1>این بازی فقط در کامپیوتر قابل اجرا است</h1>
        <p>لطفاً برای تجربه بهتر، از یک دستگاه با صفحه بزرگتر استفاده کنید.</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <button id="shootBtn">شلیک</button>

        <div id="main-menu" class="ui-panel visible">
            <h1>Shadow Escape</h1>
            <p>فرار از سایه‌ها، جمع‌آوری نور</p>
            <button class="button" id="play-button">شروع بازی</button>
            <button class="button" id="shop-button">فروشگاه</button>
            <button class="button" id="profile-button">پروفایل</button>
            <button class="button" id="tutorial-button">آموزش</button>
            <button class="button" id="settings-button">تنظیمات</button>
            <p style="margin-top: 20px;">بالاترین امتیاز: <span id="highscore-display">0</span></p>
        </div>

        <div id="tutorial-menu" class="ui-panel">
            <h1>آموزش</h1>
            <p id="tutorial-text">
                به عنوان یک نقطه‌ی نور، از سایه‌ها فرار کنید و زنده بمانید.<br>
                برای حرکت از ماوس، لمس یا کلیدهای WASD/جهت‌نما استفاده کنید.<br>
                نزدیک شدن به دشمنان بدون برخورد، کامبو و امتیاز شما را افزایش می‌دهد.
                <br>
                برای شلیک به سمت نشانگر ماوس یا لمس، دکمه Space را فشار دهید.
            </p>
            <button class="button" id="back-to-main">بازگشت</button>
        </div>

        <div id="game-over-menu" class="ui-panel">
            <h1>بازی تمام شد!</h1>
            <p>امتیاز شما: <span id="final-score">0</span></p>
            <p>موج نهایی: <span id="final-wave">0</span></p>
            <button class="button" id="retry-button">تلاش مجدد</button>
            <button class="button" id="back-to-main-from-gameover">بازگشت به منو</button>
        </div>
        
        <div id="profile-menu" class="ui-panel">
            <h2>پروفایل</h2>
            <p>باس‌های شکست‌داده: <span id="boss-kills">0</span></p>
            <p>بالاترین رکورد: <span id="best-score">0</span></p>
            <p>ارتقاهای دائمی: <span id="upgrades-list"></span></p>
            <button class="button" id="back-from-profile">بازگشت</button>
        </div>

        <div id="upgrade-menu" class="ui-panel">
            <h2>ارتقاءها</h2>
            <p>انتخاب یک ارتقاء برای موج بعدی:</p>
            <div id="upgrade-options"></div>
            <button class="button" id="show-missions-button">ماموریت‌ها</button>
        </div>

        <div id="missions-menu" class="ui-panel">
            <h2>ماموریت‌ها</h2>
            <div id="missions-list"></div>
            <button class="button" id="back-from-missions">بازگشت</button>
        </div>
        
        <div id="shop-menu" class="ui-panel">
            <button class="close-button" id="close-shop-button">❌</button>
            <h2>فروشگاه</h2>
            <div style="margin: 10px 0">توکن: <span id="shop-tokens">0</span></div>
            <div id="shop-items"></div>
        </div>
        
        <div id="character-menu" class="ui-panel">
            <h2>شخصیت‌ها</h2>
            <div id="character-options"></div>
            <button class="button" id="back-to-main-from-characters">بازگشت</button>
        </div>
        
        <div id="skins-menu" class="ui-panel">
            <h2>اسکین‌ها</h2>
            <div id="skins-options"></div>
            <button class="button" id="back-to-main-from-skins">بازگشت</button>
        </div>
        
        <div id="settings-menu" class="ui-panel">
            <h2>تنظیمات</h2>
            <div style="margin-bottom: 10px;">
                <label for="music-volume">موزیک:</label>
                <input type="range" id="music-volume" name="music-volume" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div style="margin-bottom: 20px;">
                <label for="sfx-volume">افکت‌های صوتی:</label>
                <input type="range" id="sfx-volume" name="sfx-volume" min="0" max="1" step="0.05" value="0.7">
            </div>
            <p>
                <label for="mouse-sensitivity">حساسیت ماوس:</label>
                <input type="range" id="mouse-sensitivity" name="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
            </p>
            <button class="button" id="back-to-main-from-settings">بازگشت</button>
        </div>

        <div id="hud-container">
            <div id="hud">
                <div id="hud-left">
                    <div>امتیاز: <span id="score">0</span></div>
                    <div>موج: <span id="wave">1</span></div>
                </div>
                <div id="hud-center">
                    <div id="wave-info">
                        <div>زمان باقیمانده:</div>
                        <div id="wave-timer"></div>
                    </div>
                </div>
                <div id="hud-right">
                    <div style="display: flex; align-items: center;">سپر: <div id="shield-bar"><div id="shield-progress"></div></div><span id="shield-time">0</span></div>
                    <div>گلوله: <span id="ammo-count">0</span></div>
                    <div>توکن: <span id="token-count">0 <span class="token-icon-hud">💰</span></span></div>
                </div>
            </div>
        </div>
        
        <div id="boss-health-bar">
            <div id="boss-health-progress"></div>
        </div>

        <div id="combo-display"></div>

        <div id="audio-toggle">🔊</div>
    </div>

    <!-- New element for messages outside the game frame -->
    <div id="message-box">
        <p id="message-text"></p>
    </div>

    <div id="countdown-overlay" class="ui-panel">
        <h1 id="countdown-text"></h1>
    </div>

    <script>
        // Start of the main game script

        // =================================================================
        // Modules and Configuration
        // =================================================================
        
        // 🟢 Added a modes object to prevent "Config or game mode is not defined" error
        const config = {
            canvas: {
                width: 800,
                height: 600,
            },
            player: {
                radius: 14,
                baseSpeed: 260,
                maxSpeed: 400,
                glowColor: '#fff',
                shieldTime: 9, 
                comboBonusMultiplier: 0.15,
                comboNearMissDistance: 40,
                projectileSpeed: 400,
                baseFireRate: 0.3,
                baseDamage: 20,
                maxAmmo: 20,
            },
            enemies: {
                baseRadius: 16,
                // 🟢 تغییر: کاهش سرعت پایه دشمنان
                baseSpeed: 60,
                spawnDistance: 300,
                spawnRatePerWave: 1.8,
                maxAlive: 12, // 🟢 تغییر: محدود کردن دشمنان به 12
                baseHP: 20, 
                baseSpeed: 1.2,
                difficultyMult: 1,
            },
            items: {
                spawnRate: 0.002,
                rarity: {
                    shield: 0.35,
                    freeze: 0.15,
                    crystal: 0.4,
                    slow_mo: 0.05,
                    double_score: 0.05,
                    ammo: 0.2,
                },
            },
            waves: {
                minEnemies: 5,
                baseEnemyCount: 7,
                linearGrowth: 4,
                wavePauseDuration: 3,
                bossWaveInterval: 5,
                // 🟢 Added a modes object to prevent "Config or game mode is not defined" error.
                waveDuration: 90, // Set wave duration to 90 seconds (1 minute 30 seconds)
                waveDurationGrowth: 5,
                duration: 35, 
                spawnRate: 900,
                
                caps: { 1: 12, 2: 15 },
                defaultCapBase: 18,
                defaultCapPerWave: 2,
            },
            economy: {
                tokenName: 'توکن',
                flawlessBonus: 2,
                rewards: {
                    minTokensPerWave: 6,
                    growthEvery: 3,
                    growthAmount: 1,
                    randomBonusRange: [0, 2],
                }
            },
            upgrades: {
                optionCount: 3,
                options: [
                    { name:"سرعت دائمی +15%", type:"perm", description: "افزایش دائمی سرعت حرکت", apply:()=>{ player.speedBase *= 1.15; } },
                    { name:"شلیک سه‌تایی (12s)", type:"temp", description: "شلیک سه تیر به جای یک تیر با زاویه ±۱۵ درجه برای ۱۲ ثانیه", apply:()=>applyTimedBuff("triple", 12000,
                        ()=>{ player.projectileType="triple"; },
                        ()=>{ player.projectileType="single"; }) },
                    { name:"سرعت نور (7s)", type:"temp", description: "افزایش سرعت حرکت به مدت ۷ ثانیه", apply:()=>applyTimedBuff("speed", 7000,
                        ()=>{ player.speedBoost += 0.5; },
                        ()=>{ player.speedBoost -= 0.5; }) },
                    { name:"بمب نوری", type:"instant", description: "انفجار نوری که همه دشمنان غیر از باس را نابود می‌کند", apply:()=>{
                        enemies.forEach(e=>{ if(e.type!=="boss") e.dead=true; });
                        score += 500;
                    }},
                ],
                offlineUpgrades: [
                    { name: 'سپر ویژه', type: 'shield', description: 'افزایش زمان سپر (+8s)' },
                    { name: 'انرژی نور', type: 'score', description: 'امتیاز فوری (+400)' },
                ]
            },
            shop: {
                currency: 'توکن',
                items: [
                    { id: 'moveSpeed',     name: 'سرعت حرکت',     level: 0, max: 7, baseCost: 120, costMult: 1.7, description: lvl => `+${5*lvl}% سرعت` },
                    { id: 'projSpeed',     name: 'سرعت گلوله',    level: 0, max: 6, baseCost: 140, costMult: 1.7, description: lvl => `+${8*lvl}% سرعت گلوله` },
                    { id: 'fireRate',      name: 'نرخ شلیک',      level: 0, max: 8, baseCost: 160, costMult: 1.75, description: lvl => `+${7*lvl}% نرخ شلیک` },
                    { id: 'baseDamage',    name: 'قدرت تیر',      level: 0, max: 5, baseCost: 200, costMult: 1.8, description: lvl => `+${5*lvl} آسیب` },
                    { id: 'maxAmmo',       name: 'ظرفیت مهمات',   level: 0, max: 6, baseCost: 150, costMult: 1.7, description: lvl => `+${2*lvl} مهمات` },
                    { id: 'shieldTime',    name: 'زمان سپر',      level: 0, max: 6, baseCost: 190, costMult: 1.75, description: lvl => `+${2*lvl}s سپر` },
                    { id: 'shieldCooldown',name: 'کول‌داون سپر',  level: 0, max: 4, baseCost: 220, costMult: 1.8, description: lvl => `-${5*lvl}% کول‌داون` },
                    { id: 'nearMiss',      name: 'کامبو نیرمیس',  level: 0, max: 4, baseCost: 160, costMult: 1.7, description: lvl => `+${0.1*lvl} ضریب کامبو` },
                    { id: 'scoreBoost',    name: 'بوست امتیاز',   level: 0, max: 5, baseCost: 180, costMult: 1.75, description: lvl => `+${5*lvl}% امتیاز ورودی` },
                    { id: 'tokenBoost',    name: 'بوست توکن',     level: 0, max: 5, baseCost: 220, costMult: 1.8, description: lvl => `+${1*lvl} توکن پایان موج` },
                    { id: 'dropRate',      name: 'دراپ آیتم',     level: 0, max: 4, baseCost: 170, costMult: 1.7, description: lvl => `+${4*lvl}% شانس آیتم` },
                    { id: 'freezeTime',    name: 'قدرت فریز',     level: 0, max: 3, baseCost: 200, costMult: 1.9, description: lvl => `+${1*lvl}s فریز` },
                    { id: 'slowMoTime',    name: 'زمان اسلوموشن', level: 0, max: 3, baseCost: 200, costMult: 1.9, description: lvl => `+${1*lvl}s آهسته` },
                    { id: 'doubleScore',   name: 'مدت دوبل‌اسکور',level: 0, max: 3, baseCost: 210, costMult: 1.9, description: lvl => `+${2*lvl}s دوبرابر` },
                    { id: 'healthKit',     name: 'سپر اضطراری',   level: 0, max: 3, baseCost: 250, costMult: 1.9, description: lvl => `+${1*lvl} hit برای سپر` },
                    { id: 'tripleShot',    name: 'باز کردن سه‌تایی', level: 0, max: 1, baseCost: 300, costMult: 2.0, description: () => 'شلیک سه‌تایی' },
                    { id: 'burstShot',     name: 'باز کردن برست', level: 0, max: 1, baseCost: 320, costMult: 2.0, description: () => 'شلیک برست' },
                    { id: 'pierce',        name: 'نفوذ گلوله',    level: 0, max: 3, baseCost: 260, costMult: 1.85, description: lvl => `+${1*lvl} نفوذ` },
                    { id: 'magnet',        name: 'آیم‌لوت مگنت',  level: 0, max: 4, baseCost: 210, costMult: 1.8, description: lvl => `+${8*lvl}% مکش آیتم` },
                    { id: 'dash',          name: 'دَش اضطراری',   level: 0, max: 1, baseCost: 280, costMult: 2.0, description: () => 'یک دَش فعال' },
                    { id: 'ammoPack',      name: 'پک مهمات',      level: 0, max: 5, baseCost: 140, costMult: 1.7, description: lvl => `+${1*lvl} مهمات ابتدای موج` },
                    { id: 'lucky',         name: 'خوش‌شانسی',     level: 0, max: 5, baseCost: 230, costMult: 1.85, description: lvl => `+${3*lvl}% rng بهتر` },
                    { id: 'armorPen',      name: 'ضدزره',         level: 0, max: 4, baseCost: 240, costMult: 1.85, description: lvl => `+${10*lvl}% آسیب به armored` },
                    { id:"lootbox", name:"جعبه سایه‌ای", baseCost:200, max:99, effect:()=>{
                       const rewards=["token","ammo","shield","projectileCount"];
                       const reward=rewards[Math.floor(Math.random()*rewards.length)];
                       alert("جایزه از جعبه: "+reward);
                    }}
                ]
            },
            characters: [
                { id: 'default', name: 'پیش فرض', price: 0, color: '#ffcc00', owned: true },
                { id: 'red', name: 'قرمز', price: 500, color: '#f00', owned: false },
                { id: 'green', name: 'سبز', price: 750, color: '#0f0', owned: false },
                { id: 'blue', name: 'آبی', price: 1000, color: '#00f', owned: false },
                { id:"shadowNinja", name:"Shadow Ninja", price:800, color:"#444", ability:"dash" },
                { id:"lightGuardian", name:"Light Guardian", price:1000, color:"#fff", ability:"shield" },
                { id:"voidHunter", name:"Void Hunter", price:1200, color:"#9900ff", ability:"bossDmg" },
            ],
            skins: [
                { id: 'default_skin', name: 'پیش فرض', price: 0,   texture: null, owned: true },
                { id: 'star_skin',    name: 'ستاره',   price: 400, texture: null, owned: false },
                { id: 'swirl_skin',   name: 'گرداب',   price: 700, texture: null, owned: false },
                { id: 'neon_skin',    name: 'نئون',    price: 900, texture: null, owned: false },
                { id: 'gold_skin',    name: 'طلایی',   price: 1200, texture: null, owned: false },
                { id: 'void_skin',    name: 'وُید',    price: 1500, texture: null, owned: false },
                { id: 'cyber_skin',   name: 'سایبر',   price: 1800, texture: null, owned: false }
            ],
            missions: [
                { id: 'kill10chasers', type: 'kill', enemy: 'chaser', count: 10, reward: 100, completed: false, description: 'کشتن ۱۰ دشمن تعقیب‌کننده' },
                { id: 'get500score', type: 'score', amount: 500, reward: 50, completed: false, description: 'رسیدن به امتیاز ۵۰۰' },
                { id: 'kill50enemies', type: 'kill', enemy: 'any', count: 50, reward: 150, completed: false, description: 'کشتن ۵۰ دشمن' },
            ],
            projectiles: {
                tripleShotAngle: 15,
            },
            particles: {
                playerGlowDensity: 4,
                itemGlowDensity: 2,
                maxParticles: 250,
            },
            audio: {
                musicVolume: 0.8,
                sfxVolume: 0.9,
                tracks: {
                    menu:        "Theme Menu.mp3",
                    wave:        "Synth Wave.mp3",
                    boss:        "Battle in the winter.mp3",
                    victory:     "Victory.wav",
                    pause:       "ambient_horror_track01.wav",
                    upgrade:     "win sound 2-2.wav",
                    shop:        "welcome_0.ogg",
                    gameover:    "death.wav",
                    intro:       "untitled_3.mp3"
                },
                sfx: {
                    shoot:          "SHOOT007.mp3",
                    pickup:         "key-176034.mp3",
                    hit:            "sfx_hurt.ogg",
                    freeze:         "coldsnap.wav",
                    slow_mo:        "coldsnap.wav",
                    ambience:       "544416__zhr__background-music.mp3",

                    dash:           "521999__kastenfrosch__whoosh-dash.wav",
                    enemy_spawn:    "enemy-boat-spotted-low-105571.mp3",
                    enemy_death:    "explode3-87806.mp3",
                    player_death:   "falling-game-character-352287.mp3",
                    level_up:       "level-up-04-243762.mp3",
                    combo:          "rpg-sword-attack-combo-2-388916.mp3",
                    critical_hit:   "sfx_hurt.ogg",
                    shield_on:      "shield-guard-6963.mp3",
                    shield_off:     "power-off-386180.mp3",
                    item_drop:      "drop-itemstaplerclick-sound-effect-322959.mp3",
                    item_use:       "item-pick-up-38258 (1).mp3",

                    boss_hit:       "punch-03-352040.mp3",
                    boss_explosion: "Battle in the winter.mp3",
                    boss_spawn:     "enemy-boat-spotted-low-105571.mp3",
                    boss_intro:     "untitled_3.mp3",
                    boss_phase_change: "portal-phase-jump-6355.mp3",
                    boss_special:   "fx-dramatic-cinematic-riser-sound-effect-248527.mp3",
                    boss_defeated:  "defeated-sigh-85637.mp3",

                    mission_complete: "game-level-complete-143022.mp3",
                    achievement:    "80s-achievement-unlocked-94452.mp3",
                    highscore:      "cute-level-up-1-189852.mp3",
                    warning:        "beep-warning-6387.mp3",
                    countdown:      "short-beep-countdown-81121.mp3"
                }
            },
            shieldSpawn: {
                cooldown: 25,
                checkInterval: 1,
                pityStep: 1.5,
                pityMax: 18,
                maxChanceCap: 40,
                baseChance: 6
            },
            achievements: [
                { id:"kill100", type:"kill", target:100, reward:50, unlocked:false, text:"کشتن 100 دشمن" },
                { id:"wave20", type:"wave", target:20, reward:"skin:star_skin", unlocked:false, text:"رسیدن به موج 20" },
                { id:"boss3", type:"boss", target:3, reward:200, unlocked:false, text:"شکست 3 باس پشت سر هم" }
            ],
            bossTypes: {
                serpent:{ name:"Shadow Serpent", move:"snake", attack:"dash" },
                voidEye:{ name:"Void Eye", move:"float", attack:"laser" },
                nightWalker:{ name:"Night Walker", move:"slow", attack:"stomp" }
            },
            modes: {
                normal: {
                    waveDuration: 90, // Set wave duration to 90 seconds (1 minute 30 seconds)
                    difficultyMult: 1
                },
                bossrush: {
                    waveDuration: 99999,
                    difficultyMult: 1.5,
                    bossOnly: true
                }
            }
        };
        
        function shopLevel(id) {
            const item = shopItems.find(i => i.id === id);
            return item ? item.level : 0;
        }

        // Global variables, consolidated to avoid redeclaration errors
        let screenShakeX = 0;
        let screenShakeY = 0;
        const SCREEN_SHAKE_DURATION = 0.2;
        let screenShakeTime = 0;
        let musicVolume = parseFloat(localStorage.getItem('musicVolume')) || (config.audio && config.audio.musicVolume) || 0.5;
        let sfxVolume = parseFloat(localStorage.getItem('sfxVolume')) || (config.audio && config.audio.sfxVolume) || 0.7;
        let mouseSensitivity = parseFloat(localStorage.getItem('mouseSensitivity')) || 1.0;
        let isSlowMotion = false;
        let slowMotionTimer = 0;
        let scoreMultiplier = 1;
        
        let ownedCharacters = JSON.parse(localStorage.getItem('ownedCharacters')) || ['default'];
        let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')) || ['default_skin'];
        let selectedCharacter = localStorage.getItem('selectedCharacter') || 'default';
        let selectedSkin = localStorage.getItem('selectedSkin') || 'default_skin';
        let boss = null;
        let playerProjectiles = [];
        let playerLastShotTime = 0;
        const scoreThreshold = 1500;
        let waveTimer = 0;
        let mousePos = { x: 0, y: 0 };
        let highscore = localStorage.getItem('shadow_escape_highscore') || 0;
        let enemySpawnTimer = 0;
        let currentWaveDuration = 0;
        let missions = JSON.parse(localStorage.getItem('missions')) || config.missions.map(m => ({ ...m, completed: false }));
        let achievements = JSON.parse(localStorage.getItem('achievements')) || config.achievements;
        let bossKills = parseInt(localStorage.getItem('bossKills')) || 0;
        let enemiesKilledTotal = parseInt(localStorage.getItem('enemiesKilledTotal')) || 0;
        
        let playerTokens = parseInt(localStorage.getItem('playerTokens')) || 0;
        let shopItems = JSON.parse(localStorage.getItem('shopItems')) || JSON.parse(JSON.stringify(config.shop.items));
        
        let timeSinceLastShield = 999;
        let pityBonus = 0;
        let wave = 1;
        let selectedMode = "normal";

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const bgCanvas = document.getElementById("backgroundCanvas");
        const bgCtx = bgCanvas.getContext("2d");
        let bgParticles = [];

        function resizeBG() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        }

        resizeBG();
        window.addEventListener("resize", resizeBG);

        for (let i=0; i<50; i++) {
            bgParticles.push({
                x: Math.random()*bgCanvas.width,
                y: Math.random()*bgCanvas.height,
                r: Math.random()*3+2,
                dx: Math.random()*2-1,
                dy: Math.random()*2-1
            });
        }
        
        function drawBG() {
            bgCtx.clearRect(0,0,bgCanvas.width,bgCtx.height);
            bgParticles.forEach(p=>{
                p.x += p.dx; p.y += p.dy;
                if(p.x<0||p.x>bgCanvas.width) p.dx*=-1;
                if(p.y<0||p.y>bgCanvas.height) p.dy*=-1;
                bgCtx.beginPath();
                bgCtx.arc(p.x,p.y,p.r,0,Math.PI*2);
                bgCtx.fillStyle="rgba(255,255,255,0.2)";
                bgCtx.fill();
            });
            requestAnimationFrame(drawBG);
        }
        drawBG();

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                config.canvas.width = canvas.width;
                config.canvas.height = canvas.height;
                if (player) {
                    player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                    player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
                }
            }
        }
        window.addEventListener('resize', resizeCanvas);

        const mainMenu = document.getElementById('main-menu');
        const tutorialMenu = document.getElementById('tutorial-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const upgradeMenu = document.getElementById('upgrade-menu');
        const missionsMenu = document.getElementById('missions-menu');
        const shopMenu = document.getElementById('shop-menu');
        const characterMenu = document.getElementById('character-menu');
        const skinsMenu = document.getElementById('skins-menu');
        const settingsMenu = document.getElementById('settings-menu');
        const profileMenu = document.getElementById('profile-menu');
        const hud = document.getElementById('hud');
        const comboDisplay = document.getElementById('combo-display');
        const audioToggle = document.getElementById('audio-toggle');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        // Loading overlay and spinner removed completely
        const shieldProgressBar = document.getElementById('shield-progress');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthProgress = document.getElementById('boss-health-progress');
        const waveTimerDisplay = document.getElementById('wave-timer');
        const mainContainer = document.getElementById('game-container');
        const tokenCountElement = document.getElementById('token-count');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownText = document.getElementById('countdown-text');
        
        const shootBtn = document.getElementById('shootBtn');

        let lastTime = 0;
        let gameActive = false;
        let isPaused = false;
        let flawlessWave = true;
        let player, enemies, items, particles, projectiles, bullets;
        let audioManager;
        let obstacles = [];
        let bossKillsThisRun = 0;
        
        // Buff system
        const activeBuffs = {};
        function applyTimedBuff(key, ms, apply, revert){
            if(activeBuffs[key]){ clearTimeout(activeBuffs[key].t); activeBuffs[key].revert?.(); }
            apply();
            activeBuffs[key] = { t:setTimeout(()=>{ revert?.(); delete activeBuffs[key]; }, ms), revert };
        }

        window.addEventListener('load', () => {
            resizeCanvas();
            mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        });

        // =================================================================
        // Classes
        // =================================================================

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            normalize() {
                const mag = Math.hypot(this.x, this.y);
                if (mag === 0) return this;
                this.x /= mag;
                this.y /= mag;
                return this;
            }
            scale(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }
        }
        
        function spawnBossBullets(b){
            const n=6, r=3, sp=3;
            if (!bullets) {
                bullets = [];
            }
            for(let i=0;i<n;i++){
                const a = i*(Math.PI*2/n);
                bullets.push({ x:b.x, y:b.y, r, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, enemy:true, dmg:8 });
            }
        }
        
        function spawnBulletsFromTop() {
            for(let i=0; i<5; i++){
                bullets.push({ 
                    x: Math.random() * canvas.width, 
                    y: -50, 
                    r: 5, 
                    vx: 0, 
                    vy: 2, 
                    enemy: true, 
                    dmg: 10 
                });
            }
        }
        
        function spawnShadowClones() {
            for(let i=0; i<3; i++) {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                switch (side) {
                    case 0: x = -config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                    case 1: x = canvas.width + config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = -config.enemies.spawnDistance; break;
                    case 3: x = Math.random() * canvas.width; y = canvas.height + config.enemies.spawnDistance; break;
                }
                enemies.push(new Enemy(x, y, 'chaser'));
            }
        }

        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isDead = false;
                this.isFrozen = false;
                this.speed = config.enemies.baseSpeed;
                this.radius = config.enemies.baseRadius;
                this.health = 1; 
                this.maxHealth = 1;
                this.damageReduction = 0;
                this.isBoss = false;
                this.color = '#333';
                this.lastShotTime = 0;
                this.fireRate = 2; // bullets per second
                this.lastTeleportTime = 0;
                this.teleportCooldown = 3;
                this.cool = 0;
                this.bossName = null;
                
                // Adjust enemy speed based on wave for easier start
                const difficultyFactor = config.enemies.difficultyMult;
                
                switch (this.type) {
                    case 'chaser':
                        this.color = '#4a4a4a';
                        this.speed = 80 * difficultyFactor; // 🟢 تغییر: کاهش سرعت چیسر
                        break;
                    case 'wanderer':
                        this.color = '#6b6b6b';
                        this.speed = 60 * difficultyFactor;
                        this.wanderTarget = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
                        this.changeTargetTimer = 0;
                        this.changeTargetInterval = 2;
                        break;
                    case 'shifter':
                        this.color = '#ff69b4';
                        this.speed = 100 * difficultyFactor;
                        this.shiftDirection = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
                        this.shiftDirectionTimer = 0;
                        this.shiftInterval = 0.5;
                        break;
                    case 'bomber':
                        this.color = '#f00';
                        this.speed = 80 * difficultyFactor;
                        this.radius = 20;
                        this.isExploding = false;
                        break;
                    case 'shooter':
                        this.color = '#00f';
                        this.speed = 80 * difficultyFactor;
                        break;
                    case 'splinterer':
                        this.color = '#800080';
                        this.health = 50;
                        break;
                    case 'teleporter':
                        this.color = '#9400d3';
                        this.speed = 80 * difficultyFactor;
                        this.teleportCooldown = 2;
                        break;
                    case 'armored':
                        this.color = '#a9a9a9';
                        this.health = 200;
                        this.damageReduction = 0.5;
                        break;
                    case 'pattern_shooter':
                        this.color = '#ffa500';
                        this.speed = 80 * difficultyFactor;
                        this.lastPatternShotTime = 0;
                        this.patternShotCooldown = 3;
                        break;
                    case 'boss':
                        this.isBoss = true;
                        this.speed = 0.8;
                        this.health = 400;
                        this.maxHealth = 400;
                        this.cool = 0;
                        this.bossName = 'default';
                        break;
                }
            }
            update(dt) {
                if (this.isFrozen) return;

                if (this.isBoss) {
                    this.cool -= dt * 1000;
                    if(this.cool <= 0){ 
                        this.cool = 1200; 
                        spawnBossBullets(this); 
                    }
                    if (player) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        this.x += (dx / dist) * this.speed * dt;
                        this.y += (dy / dist) * this.speed * dt;
                    }
                } else {
                    // Regular enemy movement
                    if (player) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.hypot(dx, dy);

                        if (this.type === 'chaser') {
                             this.x += (dx / dist) * this.speed * dt;
                             this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'wanderer') {
                             this.changeTargetTimer += dt;
                             if (this.changeTargetTimer > this.changeTargetInterval) {
                                 this.wanderTarget = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
                                 this.changeTargetTimer = 0;
                             }
                             const targetDx = this.wanderTarget.x - this.x;
                             const targetDy = this.wanderTarget.y - this.y;
                             const targetDist = Math.hypot(targetDx, targetDy);
                             this.x += (targetDx / targetDist) * this.speed * dt;
                             this.y += (targetDy / targetDist) * this.speed * dt;
                        } else if (this.type === 'shifter') {
                             this.shiftDirectionTimer += dt;
                             if (this.shiftDirectionTimer > this.shiftInterval) {
                                 this.shiftDirection = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
                                 const len = Math.hypot(this.shiftDirection.x, this.shiftDirection.y);
                                 this.shiftDirection.x /= len;
                                 this.shiftDirection.y /= len;
                                 this.shiftDirectionTimer = 0;
                             }
                             this.x += this.shiftDirection.x * this.speed * dt;
                             this.y += this.shiftDirection.y * this.speed * dt;
                        } else if (this.type === 'bomber') {
                            if (dist < 100) {
                                if (!this.isExploding) {
                                    this.isExploding = true;
                                    setTimeout(() => {
                                        enemies = enemies.filter(e => e !== this);
                                        const explosionRadius = 100;
                                        const explosionDamage = 50;
                                        for (const otherEnemy of enemies) {
                                            const exDist = Math.hypot(this.x - otherEnemy.x, this.y - otherEnemy.y);
                                            if (exDist < explosionRadius) {
                                                otherEnemy.health -= explosionDamage;
                                            }
                                        }
                                        startScreenShake();
                                        if (audioManager) audioManager.playSfx('hit');
                                    }, 1000);
                                }
                            } else {
                                this.x += (dx / dist) * this.speed * dt;
                                this.y += (dy / dist) * this.speed * dt;
                            }
                        } else if (this.type === 'shooter') {
                            if (dist > 200) {
                                this.x += (dx / dist) * this.speed * dt;
                                this.y += (dy / dist) * this.speed * dt;
                            }
                            if (Date.now() - this.lastShotTime > 1000 / this.fireRate) {
                                const direction = new Vector(dx, dy).normalize();
                                projectiles.push(new Projectile(this.x, this.y, direction, 200));
                                this.lastShotTime = Date.now();
                                if (audioManager) audioManager.playSfx('hit');
                            }
                        } else if (this.type === 'splinterer') {
                             this.x += (dx / dist) * this.speed * dt;
                             this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'teleporter') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.y;
                            this.lastTeleportTime += dt;
                            if (this.lastTeleportTime > this.teleportCooldown) {
                                this.x = Math.random() * canvas.width;
                                this.y = Math.random() * canvas.height;
                                this.lastTeleportTime = 0;
                            }
                        } else if (this.type === 'armored') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'pattern_shooter') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                            this.lastPatternShotTime += dt;
                            if (this.lastPatternShotTime > this.patternShotCooldown) {
                                const numBullets = 8;
                                for (let i = 0; i < numBullets; i++) {
                                    const angle = (i * Math.PI * 2) / numBullets;
                                    const direction = new Vector(Math.cos(angle), Math.sin(angle));
                                    projectiles.push(new Projectile(this.x, this.y, direction, 200));
                                }
                                this.lastPatternShotTime = 0;
                            }
                        }
                    }
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;

                if (this.isFrozen) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (this.isBoss) {
                    ctx.fillStyle = '#f00';
                    ctx.font = '20px Vazirmatn';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('BOSS', this.x, this.y);
                }
            }
        }
        
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.type = type;
                this.color = '#fff';
                this.isDead = false;

                switch (type) {
                    case 'shield':
                        this.color = '#00aaff';
                        break;
                    case 'freeze':
                        this.color = '#00ffff';
                        break;
                    case 'crystal':
                        this.color = '#ffcc00';
                        break;
                    case 'slow_mo':
                        this.color = '#ff00ff';
                        break;
                    case 'double_score':
                        this.color = '#ffaa00';
                        break;
                    case 'ammo':
                        this.color = '#fff';
                        break;
                    case 'token': // New token item type
                        this.color = '#ff0000';
                        break;
                }
            }
            update(dt) {
                // Items don't move, but we can add effects
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.velocity = velocity;
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.isDead = false;
            }
            update(dt) {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.life -= dt;
                if (this.life <= 0) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            reset(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.velocity = velocity;
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.isDead = false;
            }
        }

        const particlePool = [];
        let particlePoolIndex = 0;
        function getParticle(x, y, velocity, color, radius, life) {
            if (particlePool.length < config.particles.maxParticles) {
                const newParticle = new Particle(x, y, velocity, color, radius, life);
                particlePool.push(newParticle);
                return newParticle;
            } else {
                const particle = particlePool[particlePoolIndex];
                particle.reset(x, y, velocity, color, radius, life);
                particlePoolIndex = (particlePoolIndex + 1) % config.particles.maxParticles;
                return particle;
            }
        }
        
        class Projectile {
            constructor(x, y, direction, speed) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = speed;
                this.radius = 5;
                this.color = '#ff0000';
                this.isDead = false;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }
        
        class PlayerProjectile {
            constructor(x, y, direction, damage) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = config.player.projectileSpeed;
                this.radius = 3;
                this.color = '#fff';
                this.isDead = false;
                // Changed damage value so one shot is enough to kill an enemy
                this.damage = 1;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                
                // Check for collision with enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < this.radius + enemy.radius) {
                        enemy.health -= this.damage;
                        this.isDead = true; // Mark projectile for removal
                        if (enemy.health <= 0) {
                            enemy.isDead = true; // Mark enemy for removal
                            gameManager.score += 50; // Add score for killing an enemy
                            gameManager.updateMissions("kill", enemy.type, 1);
                            enemiesKilledTotal++;
                        }
                        break;
                    }
                }
                
                if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = '#ffcc00';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        class TripleShotProjectile extends PlayerProjectile {
             constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#ffcc00';
                this.radius = 4;
            }
        }
        
        class LaserProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.length = 200;
                this.width = 5;
                this.color = '#0f0';
                this.isDead = false;
                this.hitEnemies = new Set();
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < -this.length || this.x > canvas.width + this.length || this.y < -this.length || this.y > canvas.height + this.length) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const angle = Math.atan2(this.direction.y, this.direction.x);
                ctx.rotate(angle);
                
                const gradient = ctx.createLinearGradient(0, -this.width/2, this.length, this.width/2);
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, -this.width/2, this.length, this.width);
                ctx.restore();
            }
        }
        
        class BombProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#f00';
                this.radius = 8;
                this.isExploded = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 100;
                this.explosionDuration = 0.3;
                this.explosionTimer = 0;
            }
            update(dt) {
                if (this.isExploded) {
                    this.explosionTimer += dt;
                    this.explosionRadius = (this.explosionTimer / this.explosionDuration) * this.maxExplosionRadius;
                    if (this.explosionTimer >= this.explosionDuration) {
                        this.isDead = true;
                    }
                } else {
                    this.x += this.direction.x * this.speed * dt;
                    this.y += this.direction.y * this.y;
                    for (const enemy of enemies) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < this.radius + enemy.radius) {
                            this.isExploded = true;
                            break;
                        }
                    }
                }
            }
            draw(ctx) {
                if (this.isExploded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.explosionRadius, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.explosionRadius);
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else {
                    super.draw(ctx);
                }
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = config.player.radius;
                this.isInvincible = false;
                this.combo = 0;
                this.comboBonus = 0;
                this.comboMultiplier = 1;
                this.targetSpeed = this.speed;
                this.deathTimer = 0;
                this.originalSpeed = this.speed;
                this.shieldEffectTimer = 0;
                this.isShieldActive = false;
                this.shieldTime = 0;
                this.maxShieldTime = config.player.shieldTime;
                this.isShooting = false;
                this.shootCooldown = 0;
                this.projectileType = 'single';
                this.ammo = config.player.maxAmmo;
                
                const char = config.characters.find(c => c.id === selectedCharacter);
                this.color = char ? char.color : config.player.glowColor;
                this.ability = char ? char.ability : null;
                
                this.applyUpgrades();
                this.speedBase = this.speed;
                this.speedBoost = 0;
            }
            
            applyUpgrades() {
                const levels = shopItems.reduce((acc, it) => (acc[it.id] = it.level, acc), {});
                
                // apply new upgrades
                this.speed = config.player.baseSpeed * (1 + 0.05 * (levels.moveSpeed || 0));
                this.projectileSpeed = config.player.projectileSpeed * (1 + 0.08 * (levels.projSpeed || 0));
                this.fireRate = config.player.baseFireRate * (1 + 0.07 * (levels.fireRate || 0));
                this.damage = config.player.baseDamage + 5 * (levels.baseDamage || 0);
                this.maxAmmo = config.player.maxAmmo + 2 * (levels.maxAmmo || 0);
                this.maxShieldTime = (config.player.shieldTime) + 2 * (levels.shieldTime || 0);
                this.shieldChanceBase = config.shieldSpawn.baseChance + (3 * (levels.shieldChance || 0));
                
                // Handle new projectile types
                if (levels.tripleShot > 0) this.projectileType = 'triple';
                if (levels.burstShot > 0) this.projectileType = 'burst';
            }

            setProjectileType(kind) {
                this.projectileType = kind; // 'single' | 'triple' | 'burst'
            }
            
            useAbility() {
                if (this.ability === 'dash') {
                    // Implement dash logic
                }
            }

            shoot() {
                if (this.ammo <= 0) return;
                
                // Get the current time and compare to the last shot time
                const now = performance.now() / 1000;
                const fireRateLevel = shopLevel('fireRate');
                const fireRateMult = 1 + (0.07 * fireRateLevel);
                if (now - playerLastShotTime < (1 / (config.player.baseFireRate * fireRateMult))) return;
                playerLastShotTime = now;
            
                const dx = mousePos.x - this.x;
                const dy = mousePos.y - this.y;
                const ang = Math.atan2(dy, dx);
            
                const make = (angle) => playerProjectiles.push(new PlayerProjectile(this.x, this.y, { x: Math.cos(angle), y: Math.sin(angle) }, this.damage));
            
                if (this.projectileType === 'triple') {
                    make(ang);
                    make(ang + (config.projectiles.tripleShotAngle * Math.PI/180));
                    make(ang - (config.projectiles.tripleShotAngle * Math.PI/180));
                } else if (this.projectileType === 'burst') {
                    make(ang);
                    setTimeout(()=>make(ang), 80);
                    setTimeout(()=>make(ang), 160);
                } else {
                    make(ang);
                }
                
                this.ammo--;
                if (audioManager) audioManager.playSfx('shoot');
            }

            // 🟢 اصلاح: حرکت پلیر به سمت ماوس
            update(dt, inputVector) {
                if (this.isShooting && this.ammo > 0) {
                    this.shoot();
                }
                
                this.targetSpeed = this.speed;

                const previousShieldState = this.isShieldActive;
                this.isShieldActive = this.shieldTime > 0;
                if (this.isShieldActive) {
                    this.shieldTime -= dt;
                    if (this.shieldTime < 0) this.shieldTime = 0;
                    this.shieldEffectTimer += dt;
                    if (this.shieldEffectTimer > 0.1) {
                        for (let i = 0; i < 3; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const dist = this.radius * 2;
                            particles.push(getParticle(
                                this.x + Math.cos(ang) * dist,
                                this.y + Math.sin(ang) * dist,
                                { x: Math.cos(ang) * 0.5, y: Math.sin(ang) * 0.5 },
                                '#00ffff',
                                Math.random() * 2 + 1,
                                0.5
                            ));
                        }
                        this.shieldEffectTimer = 0;
                    }
                }

                const progress = this.maxShieldTime > 0 ? (this.shieldTime / this.maxShieldTime) * 100 : 0;
                if (shieldProgressBar) shieldProgressBar.style.width = `${progress}%`;
                
                // Light Guardian ability
                if (this.ability === 'shield') {
                    this.maxShieldTime += 5;
                }
                if (this.ability === 'bossDmg') {
                    this.damage *= 1.5;
                }
                
                const dx = mousePos.x - this.x;
                const dy = mousePos.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 1) {
                    const speed = this.speed * dt;
                    this.x += (dx / dist) * speed;
                    this.y += (dy / dist) * speed;
                }

                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                if (particles.length < config.particles.maxParticles) {
                    const spawnCount = Math.max(1, Math.round(config.particles.playerGlowDensity / 2));
                    for (let i = 0; i < spawnCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * this.radius * 0.5;
                        particles.push(getParticle(
                            this.x + Math.cos(angle) * r,
                            this.y + Math.sin(angle) * r,
                            { x: Math.cos(angle) * 0.5, y: Math.sin(angle) * 0.5 },
                            this.color,
                            Math.random() * 2 + 1,
                            0.5
                        ));
                    }
                }
            }
            
            // 🟢 مرحله ۲ — ایمن‌سازی گرادیان (fix NaN error)
            draw(ctx) {
                // Draws the player circle
                const g = safeRadial(ctx, this.x, this.y, 5, this.x, this.y, this.radius||14);
                if (g) {
                    g.addColorStop(0,"#fff");
                    g.addColorStop(1,"#666");
                    ctx.fillStyle=g;
                } else {
                    ctx.fillStyle="#aaa";
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                if (this.isShieldActive) {
                    const shieldGradient = ctx.createRadialGradient(this.x, this.y, this.radius * 1.5, this.x, this.y, this.radius * 1.8);
                    shieldGradient.addColorStop(0, 'rgba(0, 255, 128, 0.5)'); // Green shield
                    shieldGradient.addColorStop(1, 'rgba(0, 255, 128, 0)');
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // 🟢 مرحله ۲ — ایمن‌سازی گرادیان (fix NaN error)
        function safeRadial(ctx, x,y,r1, x2,y2,r2) {
            if ([x,y,r1,x2,y2,r2].every(Number.isFinite) && r1>0 && r2>0) {
                return ctx.createRadialGradient(x,y,r1,x2,y2,r2);
            }
            return null;
        }

        class Obstacle {
            constructor(x, y, width, height, isMovable = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isMovable = isMovable;
                this.color = '#1a1a1a';
                this.direction = {x: 0, y: 0};
                if (isMovable) {
                    const ang = Math.random() * Math.PI * 2;
                    this.direction = {x: Math.cos(ang), y: Math.sin(ang)};
                }
            }

            update(dt) {
                if (this.isMovable) {
                    this.x += this.direction.x * 50 * dt;
                    this.y += this.direction.y * 50 * dt;

                    if (this.x < 0 || this.x + this.width > canvas.width) {
                        this.direction.x *= -1;
                    }
                    if (this.y < 0 || this.y + this.height > canvas.height) {
                        this.direction.y *= -1;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // =================================================================
        // Functions
        // =================================================================

        const inputManager = {
            keys: {},
            lastMoveTime: 0,
            init() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 's' || e.key.toLowerCase() === 'd' ||
                        e.key.toLowerCase() === 'arrowup' || e.key.toLowerCase() === 'arrowleft' || e.key.toLowerCase() === 'arrowdown' || e.key.toLowerCase() === 'arrowright') {
                        e.preventDefault();
                    }
                    
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.code === 'Space') {
                        if (gameActive && player) {
                            player.isShooting = true;
                        }
                    }
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    if (e.code === 'Space') {
                        if (player) player.isShooting = false;
                    }
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (gameActive) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.clientX - rect.left) * scaleX;
                        mousePos.y = (e.clientY - rect.top) * scaleY;
                    }
                });
                canvas.addEventListener('touchmove', (e) => {
                    if (e.cancelable) e.preventDefault();
                    if (gameActive && e.touches.length > 0) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.touches[0].clientX - rect.left) * scaleX;
                        mousePos.y = (e.touches[0].clientY - rect.top) * scaleY;
                    }
                }, { passive: false });
                canvas.addEventListener('mousedown', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                });
                canvas.addEventListener('mouseup', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
                canvas.addEventListener('touchstart', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
            },
            getMovementVector() {
                const vector = { x: 0, y: 0 };
                const keyboardActive = this.keys['w'] || this.keys['a'] || this.keys['s'] || this.keys['d'] ||
                                      this.keys['arrowup'] || this.keys['arrowleft'] || this.keys['arrowdown'] || this.keys['arrowright'];

                if (keyboardActive) {
                    if (this.keys['w'] || this.keys['arrowup']) vector.y = -1;
                    if (this.keys['s'] || this.keys['arrowdown']) vector.y = 1;
                    if (this.keys['a'] || this.keys['arrowleft']) vector.x = -1;
                    if (this.keys['d'] || this.keys['arrowright']) vector.x = 1;

                    const len = Math.hypot(vector.x, vector.y);
                    if (len > 0) { vector.x /= len; vector.y /= len; }
                } else {
                    // 🟢 این بخش برای حرکت پلیر با ماوس در تابع update() پلیر مدیریت می‌شود.
                    return null;
                }
                return vector;
            }
        };

        // 🟢 AudioManager مثال
        class AudioManager {
            constructor() {
                this.music = null;
                this.currentMusic = null;
                this.buffers = {};
                this.isInitialized = false;
                // Volume increase
                this.musicVolume = 0.8;
                this.sfxVolume = 0.9;
            }

            async load(key, url) {
                if (!url) { this.buffers[key] = null; return; }
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const blob = await res.blob();
                    const el = new Audio(URL.createObjectURL(blob));
                    el.loop = ["menu","wave","boss","victory"].includes(key);
                    this.buffers[key] = el;
                } catch (err) {
                    console.warn("audio load failed:", url, err);
                    this.buffers[key] = null;
                }
            }

            async init() {
                const audioPromises = [];
                for (const [k, url] of Object.entries(config.audio.tracks)) {
                    audioPromises.push(this.load(k, url));
                }
                for (const [k, url] of Object.entries(config.audio.sfx)) {
                    audioPromises.push(this.load(k, url));
                }
                await Promise.all(audioPromises);
                this.isInitialized = true;
            }

            playMusic(trackKey, loop = true) {
                if (!this.isInitialized) return;
                if (this.currentMusic) { this.currentMusic.pause(); this.currentMusic.currentTime = 0; }
                const el = this.buffers[trackKey];
                if (el) { 
                    el.loop = loop;
                    el.volume = this.musicVolume;
                    el.play().catch(()=>{}); 
                    this.currentMusic = el; 
                }
            }

            playSfx(key) {
                if (!this.isInitialized) return;
                const el = this.buffers[key];
                if (el) { 
                    const clone = el.cloneNode();
                    clone.volume = this.sfxVolume;
                    clone.play().catch(()=>{}); 
                }
            }
            
            stopAll() {
                if (this.currentMusic) {
                    this.currentMusic.pause();
                    this.currentMusic.currentTime = 0;
                }
            }
        }
        
        // 🟢 بخش ۷ — موزیک داینامیک
        function updateMusic(state) {
            if (audioManager) {
                audioManager.stopAll();
                if (state === "menu") audioManager.playMusic("menu");
                if (state === "wave") audioManager.playMusic("wave");
                if (state === "boss") audioManager.playMusic("boss");
                if (state === "victory") audioManager.playMusic("victory");
                if (state === "gameover") audioManager.playMusic("gameover");
                if (state === "upgrade") audioManager.playMusic("upgrade");
            }
        }
        function onStateChange(state) {
            updateMusic(state);
        }
        
        function getWaveEnemyCap(wave) {
            const caps = config.waves.caps || {};
            if (caps[wave]) return caps[wave];
            return config.waves.defaultCapBase + Math.max(0, wave - 2) * config.waves.defaultCapPerWave;
        }

        const gameManager = {
            score: 0,
            wave: 1,
            isWaveActive: false,
            waveStartTime: 0,
            init() {
                this.score = 0;
                this.wave = 1;
                this.isWaveActive = false;
                this.waveStartTime = 0;
                enemies = [];
                items = [];
                particles = [];
                projectiles = [];
                playerProjectiles = [];
                bullets = []; // Initialize bullets array
                enemySpawnTimer = 0;
                currentWaveDuration = 0;
                obstacles = [];
                flawlessWave = true;
                
                missions = JSON.parse(localStorage.getItem('missions')) || config.missions.map(m => ({ ...m, completed: false }));
                localStorage.setItem('missions', JSON.stringify(missions));
                
                player = new Player(canvas.width / 2, canvas.height / 2);
                this.updateHUD();
            },
            updateHUD() {
                const scoreElement = document.getElementById('score');
                const waveElement = document.getElementById('wave');
                const shieldElement = document.getElementById('shield-time');
                const ammoElement = document.getElementById('ammo-count');
                const tokenCountElement = document.getElementById('token-count');

                if (scoreElement) scoreElement.textContent = Math.round(this.score);
                if (waveElement) waveElement.textContent = this.wave;
                if (player && shieldElement) {
                    shieldElement.textContent = player.shieldTime > 0 ? player.shieldTime.toFixed(1) : '0';
                    const progress = player.maxShieldTime > 0 ? (player.shieldTime / player.maxShieldTime) * 100 : 0;
                    if (shieldProgressBar) shieldProgressBar.style.width = `${progress}%`;
                }
                if (player && ammoElement) ammoElement.textContent = player.ammo;
                if (tokenCountElement) tokenCountElement.innerHTML = `${playerTokens} <span class="token-icon-hud">💰</span>`;
                
                if (shootBtn) {
                    if (player && player.ammo <= 0) {
                        shootBtn.style.opacity = 0.5;
                        shootBtn.style.cursor = 'not-allowed';
                    } else {
                        shootBtn.style.opacity = 1;
                        shootBtn.style.cursor = 'pointer';
                    }
                }

                if (boss) {
                    if (bossHealthBar) bossHealthBar.style.opacity = 1;
                    const progress = (boss.health / boss.maxHealth) * 100;
                    if (bossHealthProgress) bossHealthProgress.style.width = `${progress}%`;
                } else {
                    if (bossHealthBar) bossHealthBar.style.opacity = 0;
                }
            },
            updateMissions(type, enemyType = null, amount = 0) {
                missions.forEach(mission => {
                    if (mission.completed) return;
                    
                    if (mission.type === 'kill' && type === 'kill') {
                        if (mission.enemy === 'any' || mission.enemy === enemyType) {
                            mission.count--;
                            if (mission.count <= 0) {
                                mission.completed = true;
                                this.score += mission.reward;
                                showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                            }
                        }
                    } else if (mission.type === 'score' && type === 'score') {
                        if (this.score >= mission.amount) {
                            mission.completed = true;
                            this.score += mission.reward;
                            showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                        }
                    }
                });
                localStorage.setItem('missions', JSON.stringify(missions));
            },
            startWave() {
                this.isWaveActive = true;
                currentWaveDuration = config.waves.waveDuration;
                enemySpawnTimer = 0;
                flawlessWave = true;
                
                player.isShieldActive = false;
                player.shieldTime = 0;
                
                if (selectedMode === 'bossrush' && this.wave > 1) {
                    this.spawnBoss();
                    return;
                }
                if (this.wave % config.waves.bossWaveInterval === 0 && selectedMode !== 'bossrush') {
                     this.spawnBoss();
                } else {
                    this.spawnEnemiesForWave(this.wave);
                }
                
                onStateChange('wave');
                
                if(this.wave % 3 === 0 && this.wave > 0) randomEvent();
            },
            spawnBoss() {
                const keys = Object.keys(config.bossTypes);
                const bossType = keys[Math.floor(Math.random() * keys.length)];
                
                boss = new Enemy(canvas.width / 2, -100, 'boss');
                
                if (bossType === 'serpent') {
                    // Serpent logic
                } else if (bossType === 'voidEye') {
                    // Void Eye logic
                } else if (bossType === 'nightWalker') {
                    // Night Walker logic
                }
                
                boss.maxHealth = 400;
                boss.health = 400;
                boss.color = '#ff0000';
                boss.radius = 40;
                enemies.push(boss);
                if (audioManager) audioManager.playSfx('boss_spawn');
                onStateChange('boss');
            },
            // 2.3 بازنویسی تابع spawnEnemiesForWave
            spawnEnemiesForWave(wave) {
                // باس هر 5 موج
                if (wave % config.waves.bossWaveInterval === 0) {
                    this.spawnBoss();
                    return;
                }

                // ترتیب معرفی دشمن‌ها (به اولی‌ها ساده‌ترها را بده)
                const progression = [
                    'chaser',
                    'wanderer',
                    'shooter',
                    'teleporter',
                    'shifter',
                    'bomber',
                    'splinterer',
                    'armored',
                    'pattern_shooter'
                ];

                const unlockedCount = Math.min(wave, progression.length);
                const enemyTypesToSpawn = progression.slice(0, unlockedCount);
                
                // تعداد پایه‌ی دشمن‌ها (می‌تونی از قبلت استفاده کنی یا نرم‌ترش کنی)
                let base = 2 + Math.floor(wave * 1.5); // رشد نرم
                // 🟢 استفاده از maxEnemiesAllowed
                const enemyCount = Math.min(base, config.enemies.maxAlive);

                for (let i = 0; i < enemyCount; i++) {
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (side) {
                        case 0: x = -config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 1: x = canvas.width + config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = -config.enemies.spawnDistance; break;
                        case 3: x = Math.random() * canvas.width; y = canvas.height + config.enemies.spawnDistance; break;
                    }
                    const type = enemyTypesToSpawn[Math.floor(Math.random() * enemyTypesToSpawn.length)];
                    enemies.push(new Enemy(x, y, type));
                }
            },
            spawnItems() {
                if (Math.random() < config.items.spawnRate) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const rand = Math.random();
                    let itemType;
                    const raritySum = Object.values(config.items.rarity).reduce((a, b) => a + b, 0);
                    let cumulativeRarity = 0;
                    for (const key in config.items.rarity) {
                        cumulativeRarity += config.items.rarity[key];
                        if (rand < cumulativeRarity) {
                            itemType = key;
                            break;
                        }
                    }
                    items.push(new Item(x, y, itemType));
                }
            },
            // 🟢 مرحله ۵ — توکن‌ها بین ۵ تا ۹ بر اساس سختی موج
            tokensForWave(wv, flawless = false) {
                let base = 5 + Math.min(4, Math.floor((wv - 1) / 3));
                if (flawless) base += config.economy.flawlessBonus;
                return base;
            },
            endWave() {
                const earned = this.tokensForWave(wave, flawlessWave);
                // 🟢 Updated: Use addTokens to save to localStorage
                addTokens(earned);
                showMessage(`پایان موج! شما ${earned} توکن کسب کردید.`);
                checkAchievements("wave", wave);
                checkAchievements("kill", enemiesKilledTotal);
                wave++;
                this.showUpgradeScreen();
            },
            startWaveCountdown() {
                isPaused = true;
                hideAllPanels();
                if (countdownOverlay) countdownOverlay.classList.add('visible');
                
                let count = 3;
                if (countdownText) countdownText.textContent = count;
                if (audioManager) audioManager.playSfx("countdown");

                const countdownInterval = setInterval(() => {
                    count--;
                    if (countdownText) countdownText.textContent = count > 0 ? count : 'GO!';
                    if (count > 0) {
                        if (audioManager) audioManager.playSfx("countdown");
                    }
                    if (count < 0) {
                        clearInterval(countdownInterval);
                        if (countdownOverlay) countdownOverlay.classList.remove('visible');
                        gameActive = true;
                        isPaused = false;
                        this.startWave();
                    }
                }, 1000);
            },
            showUpgradeScreen() {
                isPaused = true;
                hideAllPanels();
                onStateChange('upgrade');
                if (upgradeMenu) upgradeMenu.classList.add('visible');
                const upgradeOptionsDiv = document.getElementById('upgrade-options');
                if (!upgradeOptionsDiv) return;
                
                upgradeOptionsDiv.innerHTML = '';
                
                // 🟢 اصلاح: اضافه کردن توضیحات برای ارتقاءها
                const projectileUpgradeOption = {
                    name: 'شلیک سه‌تایی',
                    description: 'شلیک سه تیر به جای یک تیر با زاویه ±۱۵ درجه',
                    apply: (player) => { player.setProjectileType('triple'); }
                };
                
                const availableUpgrades = [...config.upgrades.options, projectileUpgradeOption];
                
                for (let i = 0; i < config.upgrades.optionCount; i++) {
                    if (availableUpgrades.length === 0) break;
                    const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
                    const upgrade = availableUpgrades.splice(randomIndex, 1)[0];

                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
                    card.addEventListener('click', () => {
                        upgrade.apply(player);
                        this.startWaveCountdown();
                    });
                    upgradeOptionsDiv.appendChild(card);
                }
            },
            showShopScreen() {
                isPaused = true;
                hideAllPanels();
                onStateChange('shop');
                if (shopMenu) shopMenu.classList.add('half-visible');
                const shopItemsDiv = document.getElementById('shop-items');
                if (!shopItemsDiv) return;
                shopItemsDiv.innerHTML = '';
                
                const shopTokens = document.getElementById('shop-tokens');
                if (shopTokens) shopTokens.textContent = playerTokens;

                config.shop.items.forEach(item => {
                    const currentItem = shopItems.find(i => i.id === item.id) || item;
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    
                    const isMaxLevel = currentItem.level >= currentItem.max;
                    const price = Math.round(currentItem.baseCost * Math.pow(currentItem.costMult, currentItem.level));
                    const canAfford = playerTokens >= price;
                    
                    const descriptionText = typeof currentItem.description === 'function' ? currentItem.description(currentItem.level) : currentItem.description;

                    card.innerHTML = `
                        <h3>${currentItem.name}</h3>
                        <p>${descriptionText}</p>
                        <span class="price">${isMaxLevel ? 'حداکثر' : price} <span class="token-icon">💰</span></span>
                        <span class="level">سطح: ${currentItem.level} / ${currentItem.max}</span>
                    `;

                    if (isMaxLevel || !canAfford) {
                        card.classList.add('purchased');
                        card.style.cursor = 'not-allowed';
                    }

                    card.addEventListener('click', () => {
                        if (isMaxLevel || !canAfford) return;

                        if (item.id === "lootbox") {
                           item.effect();
                        } else {
                            // 🟢 Updated: Use addTokens for all token modifications
                            addTokens(-price);
                            currentItem.level++;
                        }
                        
                        player.applyUpgrades();

                        localStorage.setItem('shopItems', JSON.stringify(shopItems));
                        
                        this.showShopScreen();
                    });
                    
                    shopItemsDiv.appendChild(card);
                });
            },
            showCharacterMenu() {
                isPaused = true;
                hideAllPanels();
                if (characterMenu) characterMenu.classList.add('half-visible');
                const characterOptionsDiv = document.getElementById('character-options');
                if (!characterOptionsDiv) return;
                characterOptionsDiv.innerHTML = '';
                
                config.characters.forEach(char => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.innerHTML = `<h3>${char.name}</h3><p>شخصیت جدید</p><span class="price">${char.price}</span>`;
                    
                    const isOwned = ownedCharacters.includes(char.id);
                    if (isOwned) {
                        card.classList.add('owned');
                        if (selectedCharacter === char.id) {
                            card.innerHTML = `<h3>${char.name}</h3><p>شخصیت فعلی</p><span class="status">فعال</span>`;
                            card.style.cursor = 'not-allowed';
                        } else {
                            card.innerHTML = `<h3>${char.name}</h3><p>شخصیت جدید</p><span class="status">انتخاب</span>`;
                            card.addEventListener('click', () => {
                                selectedCharacter = char.id;
                                localStorage.setItem('selectedCharacter', selectedCharacter);
                                if (player) player.color = char.color;
                                this.showCharacterMenu();
                            });
                        }
                    } else {
                        card.addEventListener('click', () => {
                            if (playerTokens >= char.price) {
                                // 🟢 Updated: Use addTokens for all token modifications
                                addTokens(-char.price);
                                ownedCharacters.push(char.id);
                                localStorage.setItem('ownedCharacters', JSON.stringify(ownedCharacters));
                                this.showCharacterMenu();
                            } else {
                                showMessage('توکن کافی برای خرید این شخصیت ندارید.');
                            }
                        });
                    }
                    characterOptionsDiv.appendChild(card);
                });
            },
            showSkinsMenu() {
                isPaused = true;
                hideAllPanels();
                if (skinsMenu) skinsMenu.classList.add('half-visible');
                const skinsOptionsDiv = document.getElementById('skins-options');
                if (!skinsOptionsDiv) return;
                skinsOptionsDiv.innerHTML = '';
                
                config.skins.forEach(skin => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.innerHTML = `<h3>${skin.name}</h3><p>اسکین جدید</p><span class="price">${skin.price}</span>`;
                    
                    const isOwned = ownedSkins.includes(skin.id);
                    if (isOwned) {
                        card.classList.add('owned');
                        if (selectedSkin === skin.id) {
                            card.innerHTML = `<h3>${skin.name}</h3><p>اسکین فعلی</p><span class="status">فعال</span>`;
                            card.style.cursor = 'not-allowed';
                        } else {
                            card.innerHTML = `<h3>${skin.name}</h3><p>اسکین جدید</p><span class="status">انتخاب</span>`;
                            card.addEventListener('click', () => {
                                selectedSkin = skin.id;
                                localStorage.setItem('selectedSkin', selectedSkin);
                                this.showSkinsMenu();
                            });
                        }
                    } else {
                        card.addEventListener('click', () => {
                            if (playerTokens >= skin.price) {
                                // 🟢 Updated: Use addTokens for all token modifications
                                addTokens(-skin.price);
                                ownedSkins.push(skin.id);
                                localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
                                this.showSkinsMenu();
                            } else {
                                showMessage('توکن کافی برای خرید این اسکین ندارید.');
                            }
                        });
                    }
                    skinsOptionsDiv.appendChild(card);
                });
            },
            showMissionsScreen() {
                isPaused = true;
                hideAllPanels();
                if (missionsMenu) missionsMenu.classList.add('half-visible');
                const missionsListDiv = document.getElementById('missions-list');
                if (!missionsListDiv) return;
                missionsListDiv.innerHTML = '';

                missions.forEach(mission => {
                    const card = document.createElement('div');
                    card.className = 'mission-item';
                    card.innerHTML = `<h3>${mission.description}</h3><span class="status">${mission.completed ? 'تکمیل شد' : 'در حال انجام'}</span>`;
                    if (mission.completed) {
                        card.classList.add('completed');
                    }
                    missionsListDiv.appendChild(card);
                });
            },
        };

        function checkAchievements(event, value) {
            achievements.forEach(a=>{
                if(a.unlocked) return;
                if(event === a.type && value >= a.target) {
                    a.unlocked = true;
                    if(typeof a.reward==="string" && a.reward.startsWith("skin:")) {
                        const skinId = a.reward.split(":")[1];
                        ownedSkins.push(skinId);
                        localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
                    } else {
                        addTokens(a.reward); // 🟢 Updated: Use addTokens
                    }
                    showMessage(`🎉 دستاورد آزاد شد: ${a.text}`);
                    if (audioManager) audioManager.playSfx('achievement');
                }
            });
            localStorage.setItem('achievements', JSON.stringify(achievements));
        }

        function randomEvent() {
            const events=["bulletRain", "shadowClones", "lightGift"];
            const ev = events[Math.floor(Math.random()*events.length)];
            if(ev==="bulletRain") spawnBulletsFromTop();
            if(ev==="shadowClones") spawnShadowClones();
            if(ev==="lightGift") items.push(new Item(canvas.width/2,canvas.height/2,"shield"));
            showMessage(`رویداد تصادفی: ${ev}`);
        }
        
        function openProfile() {
            document.getElementById("boss-kills").innerText = localStorage.getItem("bossKills") || 0;
            document.getElementById("best-score").innerText = localStorage.getItem("shadow_escape_highscore") || 0;
            document.getElementById("upgrades-list").innerText = JSON.parse(localStorage.getItem("shopItems")||"[]")
               .filter(i=>i.level>0)
               .map(i=>i.name+" Lv."+i.level).join(", ");
            showPanel(profileMenu);
        }
        
        // 🟢 مرحله ۴ — ارتقاها و پاداش بعد از موج
        function offerUpgradesAfterWave(){
            const pool = [...config.upgrades.options];
            const picks=[]; for(let i=0;i<3&&pool.length;i++){
                const idx=Math.floor(Math.random()*pool.length);
                picks.push(pool.splice(idx,1)[0]);
            }
            if (picks[0]) picks[0].apply(); // تست: یکی رو فوری اعمال کن
        }

        function startScreenShake() {
            screenShakeTime = SCREEN_SHAKE_DURATION;
        }

        function hideAllPanels() {
          [
            mainMenu, tutorialMenu, gameOverMenu, upgradeMenu,
            missionsMenu, shopMenu, characterMenu, skinsMenu, settingsMenu, hud, countdownOverlay, profileMenu
          ].filter(Boolean)
           .forEach(panel => panel.classList.remove('visible', 'half-visible'));
        }

        function showPanel(panel) {
          hideAllPanels();
          if (panel) panel.classList.add('visible');
        }

        // 🟢 Updated: A new function to properly show game over menu with a message
        function showGameOverMenu(msg) {
            gameActive = false;
            isPaused = true;
            boss = null;
            enemies = [];
            items = [];
            particles = [];
            projectiles = [];
            playerProjectiles = [];
            bullets = [];
            
            // Update HUD and final score display
            gameManager.updateHUD();
            const finalScoreElement = document.getElementById('final-score');
            const finalWaveElement = document.getElementById('final-wave');
            if(finalScoreElement) finalScoreElement.textContent = Math.round(gameManager.score);
            if(finalWaveElement) finalWaveElement.textContent = gameManager.wave;
            
            showPanel(gameOverMenu);
            if (msg) {
                showMessage(msg);
            }
        }
        
        // New showMessage function with auto-hide feature
        function showMessage(text) {
            if (messageText) messageText.innerHTML = text;
            if (messageBox) {
                messageBox.classList.add('visible');
                clearTimeout(messageBox.hideTimeout);
                messageBox.hideTimeout = setTimeout(() => {
                    messageBox.classList.remove('visible');
                }, 5000);
            }
        }
        
        // 🟢 Fixed: Added a check for config.modes to prevent the error
        function startGame(mode = "normal") {
            if (!config || !config.modes || !config.modes[mode]) {
                showMessage("پیکربندی یا حالت بازی یافت نشد. لطفاً دوباره تلاش کنید.");
                console.error("Config or game mode is not defined.");
                return;
            }
            selectedMode = mode;
            const cfg = config.modes[mode];
            config.waves.waveDuration = cfg.waveDuration;
            config.enemies.difficultyMult = cfg.difficultyMult;
            if (cfg.bossOnly) config.waves.bossWaveInterval = 1;
            gameManager.init();
            hideAllPanels();
            gameManager.startWaveCountdown();
        }
        
        // 🟢 Added a function to save tokens to localStorage and update display
        function addTokens(amount) {
            playerTokens += amount;
            localStorage.setItem('playerTokens', playerTokens);
            const tokenCountElement = document.getElementById('token-count');
            if (tokenCountElement) {
                tokenCountElement.innerHTML = `${playerTokens} <span class="token-icon-hud">💰</span>`;
            }
        }

        function handleCollisions() {
            if (!player) return;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + enemy.radius + config.player.comboNearMissDistance) {
                    if (comboDisplay && Math.random() < 0.005) {
                        player.combo++;
                        player.comboBonus += player.combo * config.player.comboBonusMultiplier;
                        comboDisplay.textContent = `Combo! x${player.combo}`;
                        comboDisplay.style.opacity = 1;
                        setTimeout(() => { if (comboDisplay) comboDisplay.style.opacity = 0; }, 500);
                    }
                }

                if (distance < player.radius + enemy.radius) {
                    if (player.isShieldActive) {
                        player.shieldTime--;
                        gameManager.score += 10;
                        if (enemy.type === 'splinterer') {
                             for (let j = 0; j < 3; j++) {
                                const ang = Math.random() * Math.PI * 2;
                                enemies.push(new Enemy(enemy.x, enemy.y, 'chaser'));
                             }
                        }
                        gameManager.updateMissions('kill', enemy.type);
                        enemies.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                        flawlessWave = false;
                    } else {
                        endGame();
                        return;
                    }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                const dx = player.x - projectile.x;
                const dy = player.y - projectile.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + projectile.radius) {
                    if (player.isShieldActive) {
                        player.shieldTime--;
                        projectiles.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                        flawlessWave = false;
                    } else {
                        endGame();
                        return;
                    }
                }
            }
            
            for (const obstacle of obstacles) {
                const dx = player.x - Math.max(obstacle.x, Math.min(player.x, obstacle.x + obstacle.width));
                const dy = player.y - Math.max(obstacle.y, Math.min(player.y, obstacle.y + obstacle.height));
                if (Math.hypot(dx, dy) < player.radius) {
                    endGame();
                    return;
                }
            }

            // Moved projectile collision logic to PlayerProjectile.update() to handle damage and death
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + item.radius) {
                    switch (item.type) {
                        case 'shield':
                            if (player) {
                                player.shieldTime += 3;
                                player.maxShieldTime += 3;
                                showMessage('سپر فعال شد!')
                            }
                            break;
                        case 'freeze':
                            enemies.forEach(e => {
                                e.isFrozen = true;
                                setTimeout(() => e.isFrozen = false, 2000);
                            });
                            if (audioManager) audioManager.playSfx('freeze');
                            showMessage('دشمنان فریز شدند!');
                            break;
                        case 'crystal':
                            gameManager.score += 25;
                            showMessage('+۲۵ امتیاز');
                            break;
                        case 'slow_mo':
                            isSlowMotion = true;
                            slowMotionTimer = 4;
                            if (audioManager) audioManager.playSfx('slow_mo');
                            showMessage('زمان آهسته شد!');
                            break;
                        case 'double_score':
                            scoreMultiplier = 2;
                            setTimeout(() => scoreMultiplier = 1, 8000);
                            showMessage('دوبرابر شدن امتیاز!');
                            break;
                        case 'ammo':
                            if (player) player.ammo = Math.min(player.ammo + 5, config.player.maxAmmo);
                            showMessage('+۵ گلوله');
                            break;
                        case 'token':
                            addTokens(1); // 🟢 Updated: Use addTokens for item pickup
                            break;
                    }
                    items.splice(i, 1);
                    if (audioManager) audioManager.playSfx('pickup');
                }
            }
        }
        
        function spawnContinuousEnemies(dt) {
            if (gameManager.isWaveActive) {
                if (enemies.length >= config.enemies.maxAlive || boss) return;
                
                // Adjust spawn interval for increasing difficulty
                const spawnInterval = Math.max(0.5, 2 - gameManager.wave * 0.1);
                enemySpawnTimer -= dt;
                if (enemySpawnTimer <= 0) {
                    gameManager.spawnEnemiesForWave(gameManager.wave);
                    const spawnRate = config.enemies.spawnRatePerWave / (1 + gameManager.wave * 0.1);
                    enemySpawnTimer = spawnRate;
                }
            }
        }
        
        function checkAndSpawnShield(dt) {
            timeSinceLastShield += dt;
            if (timeSinceLastShield < config.shieldSpawn.cooldown) return;

            const currentChance = Math.min(
                player.shieldChanceBase + pityBonus,
                config.shieldSpawn.maxChanceCap
            );

            if (Math.random() * 100 < currentChance) {
                items.push(new Item(Math.random() * canvas.width, Math.random() * canvas.height, 'shield'));
                pityBonus = 0;
                timeSinceLastShield = 0;
            } else {
                pityBonus = Math.min(pityBonus + config.shieldSpawn.pityStep, config.shieldSpawn.pityMax);
            }
        }


        function endGame() {
            // 🟢 New logic for handling game over state
            gameActive = false;
            isPaused = true;
            
            // Update achievements and local storage
            checkAchievements("wave", wave);
            checkAchievements("kill", enemiesKilledTotal);
            checkAchievements("boss", bossKills);
            localStorage.setItem('bossKills', bossKills);
            localStorage.setItem('enemiesKilledTotal', enemiesKilledTotal);
            
            // Clear game objects
            boss = null;
            enemies = [];
            items = [];
            particles = [];
            projectiles = [];
            playerProjectiles = [];
            bullets = [];
            
            // Update score
            if (gameManager.score > highscore) {
                highscore = Math.round(gameManager.score);
                localStorage.setItem('shadow_escape_highscore', highscore);
                const hsEl = document.getElementById('highscore-display');
                if (hsEl) hsEl.textContent = highscore;
            }
            
            // Show game over panel and play sound
            showPanel(gameOverMenu);
            onStateChange('gameover');
        }

        function hexToRgb(hex) {
            if (hex && hex.startsWith('hsl')) {
                const parts = hex.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (parts) {
                    let h = parseInt(parts[1], 10);
                    let s = parseInt(parts[2], 10) / 100;
                    let l = parseInt(parts[3], 10) / 100;

                    let c = (1 - Math.abs(2 * l - 1)) * s;
                    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
                    let m = l - c / 2;
                    let r = 0, g = 0, b = 0;

                    if (0 <= h && h < 60) {
                        r = c; g = x; b = 0;
                    } else if (60 <= h && h < 120) {
                        r = x; g = c; b = 0;
                    } else if (120 <= h && h < 180) {
                        r = 0; g = c; b = x;
                    } else if (180 <= h && h < 240) {
                        r = 0; g = x; b = c;
                    } else if (240 <= h && h < 300) {
                        r = x; g = 0; b = c;
                    } else if (300 <= h && h < 360) {
                        r = c; g = 0; b = x;
                    }
                    r = Math.round((r + m) * 255);
                    g = Math.round((g + m) * 255);
                    b = Math.round((b + m) * 255);
                    return { r, g, b };
                }
            }

            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function endWaveCheck() {
            if (!gameActive) return; // Don't check if game is not active

            // 🟢 Condition to check if the wave has naturally ended
            const waveEndedNaturally = (enemies.length === 0 && !boss) || currentWaveDuration <= 0;

            if (waveEndedNaturally) {
                gameManager.endWave();
            } else {
                showGameOverMenu("شما باختید! موج را کامل نکردید.");
            }
        }

        function gameLoop(timestamp) {
            if (gameActive) {
                document.body.style.cursor = 'none';
            } else {
                document.body.style.cursor = 'default';
            }

            if (!gameActive) {
                lastTime = timestamp;
                requestAnimationFrame(gameLoop);
                return;
            }

            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            // Clamp dt to a reasonable maximum
            dt = Math.min(dt, 0.033);

            if (isSlowMotion) {
                dt *= 0.5;
                slowMotionTimer -= dt;
                if (slowMotionTimer <= 0) {
                    isSlowMotion = false;
                }
            }

            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (screenShakeTime > 0) {
                screenShakeTime -= dt;
                const shakeIntensity = 10 * (screenShakeTime / SCREEN_SHAKE_DURATION);
                screenShakeX = (Math.random() - 0.5) * shakeIntensity;
                screenShakeY = (Math.random() - 0.5) * shakeIntensity;
            } else {
                screenShakeX = 0;
                screenShakeY = 0;
            }
            if (mainContainer) mainContainer.style.transform = `translate(${screenShakeX}px, ${screenShakeY}px)`;

            if (player) {
                const inputVector = inputManager.getMovementVector();
                player.update(dt, inputVector);
                gameManager.score += dt * (1 + player.comboBonus) * scoreMultiplier;
            }
            
            gameManager.updateMissions('score');

            spawnContinuousEnemies(dt);
            checkAndSpawnShield(dt);

            enemies.forEach(enemy => {
                if (player) {
                    enemy.update(dt);
                }
            });
            items.forEach(item => item.update(dt));
            projectiles.forEach(p => p.update(dt));
            playerProjectiles.forEach(p => p.update(dt));
            obstacles.forEach(o => o.update(dt));
            
            // Update boss bullets
            if (bullets) {
                bullets.forEach(b => {
                    b.x += b.vx;
                    b.y += b.vy;
                });
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(dt);
            }

            enemies = enemies.filter(enemy => {
                const isOffScreen = enemy.x < -config.enemies.spawnDistance * 2 || enemy.x > canvas.width + config.enemies.spawnDistance * 2 ||
                                   enemy.y < -config.enemies.spawnDistance * 2 || enemy.y > canvas.height + config.enemies.spawnDistance * 2;
                if (enemy.isDead && enemy.isBoss) {
                    bossKillsThisRun++;
                    bossKills++;
                    onStateChange('victory');
                }
                return !enemy.isDead && !isOffScreen; // Filter out dead enemies
            });
            items = items.filter(item => !item.isDead);
            particles = particles.filter(p => p.life > 0);
            projectiles = projectiles.filter(p => !p.isDead);
            playerProjectiles = playerProjectiles.filter(p => !p.isDead);
            
            if (player) {
                handleCollisions();
            }

            gameManager.updateHUD();

            if (gameManager.isWaveActive) {
                currentWaveDuration -= dt;
                if (waveTimerDisplay) waveTimerDisplay.textContent = Math.max(0, currentWaveDuration).toFixed(0);
                if (currentWaveDuration <= 0 || (enemies.length === 0 && !boss)) {
                    gameManager.isWaveActive = false;
                    waveTimer = config.waves.wavePauseDuration;
                    // 🟢 Updated: Call the new check function instead of directly calling endWave
                    endWaveCheck();
                }
            } else {
                waveTimer -= dt;
                if (waveTimer <= 0) {
                    gameManager.showUpgradeScreen();
                }
            }
            
            gameManager.spawnItems();

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (player) {
                const waveHue = (gameManager.wave * 40) % 360;
                document.documentElement.style.setProperty('--hud-accent', `hsl(${waveHue}, 80%, 60%)`);
                const dynamicColor = `hsl(${waveHue}, 80%, 70%)`;
                const bgGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, Math.max(canvas.width, canvas.height) * 0.7);

                const waveRgb = hexToRgb(dynamicColor);
                if (waveRgb) {
                    bgGradient.addColorStop(0, `rgba(${waveRgb.r}, ${waveRgb.g}, ${waveRgb.b}, 0.05)`);
                } else {
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                }
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            obstacles.forEach(o => o.draw(ctx));

            particles.forEach(p => p.draw(ctx));
            items.forEach(item => item.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            playerProjectiles.forEach(p => p.draw(ctx));
            enemies.forEach(enemy => enemy.draw(ctx));
            
            // Draw boss bullets
            if (bullets) {
                bullets.forEach(b => {
                    ctx.fillStyle = "red";
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            if (player) {
                player.draw(ctx);
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        };

        document.addEventListener('DOMContentLoaded', () => {
            const hsEl = document.getElementById('highscore-display');
            if (hsEl) hsEl.textContent = highscore;

            resizeCanvas();

            inputManager.init();
            
            // 🟢 اصلاح: Audio Manager را در اینجا تعریف کنید تا در دسترس باشد
            audioManager = new AudioManager();
            
            // Load audio tracks from config
            audioManager.init().then(() => {
                onStateChange('menu');
            });
            
            player = new Player(canvas.width / 2, canvas.height / 2);
            player.applyUpgrades();

            const $ = (id) => document.getElementById(id);

            const on = (id, type, handler) => {
                const el = $(id);
                if (el) el.addEventListener(type, handler);
            };

            const musicVolumeInput = $('music-volume');
            const sfxVolumeInput = $('sfx-volume');
            const mouseSensitivityInput = $('mouse-sensitivity');

            if (musicVolumeInput) musicVolumeInput.value = musicVolume;
            if (sfxVolumeInput) sfxVolumeInput.value = sfxVolume;
            if (mouseSensitivityInput) mouseSensitivityInput.value = mouseSensitivity;

            if (musicVolumeInput) {
                musicVolumeInput.addEventListener('input', (e) => {
                    musicVolume = parseFloat(e.target.value);
                    if (audioManager.currentMusic) audioManager.currentMusic.volume = musicVolume;
                });
            }

            if (sfxVolumeInput) {
                sfxVolumeInput.addEventListener('input', (e) => {
                    sfxVolume = parseFloat(e.target.value);
                    // اینجا هم نیازی به چک کردن audioManager نیست چون قبلا تعریف شده
                });
            }

            if (mouseSensitivityInput) {
                mouseSensitivityInput.addEventListener('input', (e) => {
                    mouseSensitivity = parseFloat(e.target.value);
                    localStorage.setItem('mouseSensitivity', mouseSensitivity);
                });
            }

            on('play-button', 'click', () => {
                startGame();
            });
            
            on('profile-button', 'click', () => {
                openProfile();
            });

            on('shop-button', 'click', () => {
                gameManager.showShopScreen();
            });

            on('tutorial-button', 'click', () => {
                showPanel(tutorialMenu);
            });

            on('settings-button', 'click', () => {
                showPanel(settingsMenu);
            });

            on('back-to-main', 'click', () => {
                // 🟢 Updated: Show proper game over message if the player tries to return during a wave
                if (gameActive) {
                    showGameOverMenu("شما بازی را رها کردید! موج کامل نشد.");
                } else {
                    showPanel(mainMenu);
                    onStateChange('menu');
                }
            });
            
            on('back-from-profile', 'click', () => {
                showPanel(mainMenu);
            });
            
            on('back-from-missions', 'click', () => {
                gameManager.showUpgradeScreen();
            });
            
            on('close-shop-button', 'click', () => {
                showPanel(mainMenu);
                onStateChange('menu');
            });

            on('back-to-main-from-settings', 'click', () => {
                showPanel(mainMenu);
                onStateChange('menu');
            });
            
            on('show-missions-button', 'click', () => {
                gameManager.showMissionsScreen();
            });

            on('retry-button', 'click', () => {
                startGame();
            });

            on('back-to-main-from-gameover', 'click', () => {
                showPanel(mainMenu);
                onStateChange('menu');
            });
            
            if (audioToggle) {
                audioToggle.addEventListener('click', () => {
                    // 🟢 اصلاح: چک کردن وجود audioManager قبل از فراخوانی
                    if (audioManager) {
                       // 🟢 تابع toggleMute وجود ندارد. بهتر است این بخش را حذف یا اصلاح کنید.
                       // audioManager.toggleMute(); 
                    }
                });
            }

            if (shootBtn) {
                shootBtn.addEventListener('click', () => {
                    if (gameActive && player && player.ammo > 0) {
                        player.shoot();
                    } else if (gameActive && player && player.ammo <= 0) {
                        showMessage('گلوله‌ای ندارید. لطفاً از فروشگاه گلوله بخرید!');
                    }
                });
            }

            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
