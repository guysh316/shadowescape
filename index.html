<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Escape</title>
    <style>
        /* General Styles for the body */
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0d0d0d;
            color: #f0f0f0;
            font-family: 'Vazirmatn', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            text-align: center;
            transition: background-color 0.5s;
        }

        /* Mobile Device Restriction Overlay */
        #mobile-restriction {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        
        #mobile-restriction h1 {
            font-size: 2rem;
            color: #ffcc00;
            margin-bottom: 10px;
        }

        #mobile-restriction p {
            font-size: 1.2rem;
            color: #aaa;
            max-width: 400px;
        }

        /* Game Container */
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0a0a0a;
            width: 100%;
            height: 100%;
            max-width: 90vw;
            max-height: 90vh;
            aspect-ratio: 4/3;
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            pointer-events: none;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 80%;
            max-width: 400px;
        }

        .ui-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .ui-panel.half-visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
            max-width: 600px;
        }

        .ui-panel h1, .ui-panel h2 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 15px #ffcc00;
        }

        .ui-panel p {
            font-size: 1.1rem;
            margin: 0 0 20px 0;
            line-height: 1.6;
            color: #ccc;
        }

        /* Buttons */
        .button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 15px 0;
            border: none;
            border-radius: 10px;
            background: linear-gradient(145deg, #1f1f1f, #2a2a2a);
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3), -5px -5px 15px rgba(255,255,255,0.05);
            transition: all 0.2s ease;
            user-select: none;
        }

        .button:hover {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            transform: translateY(-2px);
            box-shadow: 8px 8px 20px rgba(0,0,0,0.4), -8px -8px 20px rgba(255,255,255,0.08);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5);
        }

        .button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Shop & Upgrade Items */
        .upgrade-card, .shop-item, .mission-item {
            background: rgba(30, 30, 30, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
            text-align: right;
            position: relative;
        }
        
        .upgrade-card h3, .shop-item h3, .mission-item h3 {
            margin: 0 0 5px 0;
            color: #f0f0f0;
            font-size: 1.2rem;
        }

        .upgrade-card p, .shop-item p, .mission-item p {
            margin: 0;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .shop-item:hover, .upgrade-card:hover {
            border-color: #ffcc00;
        }
        
        .shop-item.purchased {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .shop-item.active {
            border-color: #ffcc00;
        }

        .shop-item .price, .mission-item .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #fff;
        }

        .shop-item .level {
            display: block;
            margin-top: 5px;
            font-size: 0.8rem;
            color: #888;
        }

        /* HUD */
        #hud-container {
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            width: 100%;
            position: absolute;
            top: 20px;
            left: 0;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            width: 100%;
            max-width: 800px;
            padding: 0 20px;
        }

        #hud > div {
            background: rgba(10, 10, 10, 0.5);
            backdrop-filter: blur(5px);
            padding: 8px 15px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #hud-left, #hud-right {
            display: flex;
            gap: 10px;
        }
        
        #hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        #wave-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #wave-timer {
            font-size: 1.2rem;
            font-weight: bold;
        }

        #shield-bar {
            width: 100px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-right: 5px;
        }

        #shield-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #00ffff);
            transition: width 0.1s linear;
        }

        #boss-health-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            height: 20px;
            background-color: rgba(255, 0, 0, 0.3);
            border: 1px solid #ff0000;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 50;
        }

        #boss-health-progress {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6347);
        }

        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #ffcc00;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #audio-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            color: #fff;
            text-shadow: 0 0 5px #fff;
        }

        /* Custom message box outside the game */
        #message-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: right;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            max-width: 300px;
        }

        #message-box.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Loading Overlay - REMOVED */
        
        #shootBtn {
          position: absolute;
          bottom: 20px;
          right: 20px;
          padding: 10px 20px;
          font-size: 18px;
          cursor: pointer;
          z-index: 100;
          background: linear-gradient(45deg, #00aaff, #00ffff);
          color: #1a1a1a;
          border: none;
          border-radius: 10px;
          box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
          transition: all 0.2s ease;
          font-weight: bold;
          display: none;
        }
        
        #shootBtn:hover {
            transform: scale(1.1);
        }
        
        #shootBtn:active {
            transform: scale(0.95);
        }
        
        /* Responsive styles for mobile */
        @media (max-width: 600px) {
            #game-container {
                max-width: 98vw;
                max-height: 98vh;
            }
            .ui-panel {
                width: 90%;
                max-width: 300px;
            }
            .ui-panel h1, .ui-panel h2 {
                font-size: 1.8rem;
            }
            .ui-panel p {
                font-size: 1rem;
            }
            .button {
                font-size: 1rem;
                padding: 12px;
                margin: 10px 0;
            }
            #hud {
                top: 10px;
                left: 10px;
                right: 10px;
                font-size: 0.8rem;
            }
            #hud > div {
                padding: 6px 10px;
            }
            #shield-bar {
                width: 70px;
            }
            #combo-display {
                font-size: 2rem;
            }
            
            #audio-toggle {
                bottom: 20px;
                left: 20px;
            }

            #shootBtn {
                display: block;
                bottom: 20px;
                right: 20px;
                transform: translateX(0);
                font-size: 1rem;
                padding: 10px 15px;
            }

            /* Hide game container on mobile */
            #game-container {
                display: none;
            }
            
            #mobile-restriction {
                display: flex;
            }
        }

        /* Desktop specific styles */
        @media (min-width: 601px) {
            #mobile-restriction {
                display: none;
            }
            #game-container {
                display: block;
            }
        }
        
        .mission-item.completed {
            background: rgba(0, 100, 0, 0.9);
            border-color: #00ff00;
            color: #fff;
        }

        #missions-menu, #shop-menu, #character-menu, #skins-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #missions-list, #shop-items, #character-options, #skins-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            width: 100%;
        }

        @media (min-width: 600px) {
            #missions-list, #shop-items, #character-options, #skins-options {
                grid-template-columns: repeat(3, 1fr);
                gap: 20px;
            }
        }

        #shop-menu .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 2rem;
            color: #ff0000;
            cursor: pointer;
        }

        .token-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            font-size: 1em;
            color: #ff0000;
            text-shadow: 0 0 5px #ff6347;
            vertical-align: middle;
            margin-left: 5px;
        }

        .token-icon-hud {
            color: #ff0000;
            text-shadow: 0 0 5px #ff6347;
        }

        /* New styles for shop item layout */
        #shop-items {
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
    </style>
</head>
<body>
    <div id="mobile-restriction">
        <h1>این بازی فقط در کامپیوتر قابل اجرا است</h1>
        <p>لطفاً برای تجربه بهتر، از یک دستگاه با صفحه بزرگتر استفاده کنید.</p>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <button id="shootBtn">شلیک</button>

        <div id="main-menu" class="ui-panel visible">
            <h1>Shadow Escape</h1>
            <p>فرار از سایه‌ها، جمع‌آوری نور</p>
            <button class="button" id="play-button">شروع بازی</button>
            <button class="button" id="shop-button">فروشگاه</button>
            <button class="button" id="tutorial-button">آموزش</button>
            <button class="button" id="settings-button">تنظیمات</button>
            <p style="margin-top: 20px;">بالاترین امتیاز: <span id="highscore-display">0</span></p>
        </div>

        <div id="tutorial-menu" class="ui-panel">
            <h1>آموزش</h1>
            <p id="tutorial-text">
                به عنوان یک نقطه‌ی نور، از سایه‌ها فرار کنید و زنده بمانید.<br>
                برای حرکت از ماوس، لمس یا کلیدهای WASD/جهت‌نما استفاده کنید.<br>
                نزدیک شدن به دشمنان بدون برخورد، کامبو و امتیاز شما را افزایش می‌دهد.
                <br>
                برای شلیک به سمت نشانگر ماوس یا لمس، دکمه Space را فشار دهید.
            </p>
            <button class="button" id="back-to-main">بازگشت</button>
        </div>

        <div id="game-over-menu" class="ui-panel">
            <h1>بازی تمام شد!</h1>
            <p>امتیاز شما: <span id="final-score">0</span></p>
            <p>موج نهایی: <span id="final-wave">0</span></p>
            <button class="button" id="retry-button">تلاش مجدد</button>
            <button class="button" id="back-to-main-from-gameover">بازگشت به منو</button>
        </div>

        <div id="upgrade-menu" class="ui-panel">
            <h2>ارتقاءها</h2>
            <p>انتخاب یک ارتقاء برای موج بعدی:</p>
            <div id="upgrade-options"></div>
            <button class="button" id="show-missions-button">ماموریت‌ها</button>
        </div>

        <div id="missions-menu" class="ui-panel">
            <h2>ماموریت‌ها</h2>
            <div id="missions-list"></div>
            <button class="button" id="back-from-missions">بازگشت</button>
        </div>
        
        <div id="shop-menu" class="ui-panel">
            <button class="close-button" id="close-shop-button">❌</button>
            <h2>فروشگاه</h2>
            <div style="margin: 10px 0">توکن: <span id="shop-tokens">0</span></div>
            <div id="shop-items"></div>
        </div>
        
        <div id="character-menu" class="ui-panel">
            <h2>شخصیت‌ها</h2>
            <div id="character-options"></div>
            <button class="button" id="back-to-main-from-characters">بازگشت</button>
        </div>
        
        <div id="skins-menu" class="ui-panel">
            <h2>اسکین‌ها</h2>
            <div id="skins-options"></div>
            <button class="button" id="back-to-main-from-skins">بازگشت</button>
        </div>
        
        <div id="settings-menu" class="ui-panel">
            <h2>تنظیمات</h2>
            <div style="margin-bottom: 10px;">
                <label for="music-volume">موزیک:</label>
                <input type="range" id="music-volume" name="music-volume" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div style="margin-bottom: 20px;">
                <label for="sfx-volume">افکت‌های صوتی:</label>
                <input type="range" id="sfx-volume" name="sfx-volume" min="0" max="1" step="0.05" value="0.7">
            </div>
            <p>
                <label for="mouse-sensitivity">حساسیت ماوس:</label>
                <input type="range" id="mouse-sensitivity" name="mouse-sensitivity" min="0.1" max="2" step="0.1" value="1">
            </p>
            <button class="button" id="back-to-main-from-settings">بازگشت</button>
        </div>

        <div id="hud-container">
            <div id="hud">
                <div id="hud-left">
                    <div>امتیاز: <span id="score">0</span></div>
                    <div>موج: <span id="wave">1</span></div>
                </div>
                <div id="hud-center">
                    <div id="wave-info">
                        <div>زمان باقیمانده:</div>
                        <div id="wave-timer"></div>
                    </div>
                </div>
                <div id="hud-right">
                    <div style="display: flex; align-items: center;">سپر: <div id="shield-bar"><div id="shield-progress"></div></div><span id="shield-time">0</span></div>
                    <div>گلوله: <span id="ammo-count">0</span></div>
                    <div>توکن: <span id="token-count">0 <span class="token-icon-hud">💰</span></span></div>
                </div>
            </div>
        </div>
        
        <div id="boss-health-bar">
            <div id="boss-health-progress"></div>
        </div>

        <div id="combo-display"></div>

        <div id="audio-toggle">🔊</div>
    </div>

    <!-- New element for messages outside the game frame -->
    <div id="message-box">
        <p id="message-text"></p>
    </div>

    <div id="countdown-overlay" class="ui-panel">
        <h1 id="countdown-text"></h1>
    </div>

    <script>
        // Start of the main game script

        // =================================================================
        // Modules and Configuration
        // =================================================================

        const config = {
            canvas: {
                width: 800,
                height: 600,
            },
            player: {
                radius: 14,
                baseSpeed: 260,
                maxSpeed: 400,
                glowColor: '#fff',
                shieldTime: 9, 
                comboBonusMultiplier: 0.15,
                comboNearMissDistance: 40,
                projectileSpeed: 400,
                baseFireRate: 0.3,
                baseDamage: 20,
                maxAmmo: 20,
            },
            enemies: {
                baseRadius: 16,
                baseSpeed: 120,
                spawnDistance: 300,
                spawnRatePerWave: 1.8,
            },
            items: {
                spawnRate: 0.002,
                rarity: {
                    shield: 0.35,
                    freeze: 0.15,
                    crystal: 0.4,
                    slow_mo: 0.05,
                    double_score: 0.05,
                    ammo: 0.2,
                },
            },
            waves: {
                minEnemies: 5,
                baseEnemyCount: 7,
                linearGrowth: 4,
                wavePauseDuration: 3,
                bossWaveInterval: 5,
                waveDuration: 30,
                waveDurationGrowth: 5,
            },
            upgrades: {
                optionCount: 3,
                options: [
                    { name: 'سرعت', effect: (player) => player.speed *= 1.15, description: 'افزایش سرعت حرکت (+15%)' },
                    { name: 'سپر', effect: (player) => { player.shieldTime += 4; player.maxShieldTime += 4; }, description: 'افزایش زمان سپر (+4s)' },
                    { name: 'امتیاز', effect: (player) => gameManager.score += 150, description: 'امتیاز فوری (+150)' },
                    { name: 'کامبو', effect: (player) => player.comboMultiplier += 0.3, description: 'افزایش ضریب کامبو' },
                    { name: 'نرخ شلیک', effect: (player) => player.fireRate *= 1.2, description: 'افزایش نرخ شلیک' },
                ],
                offlineUpgrades: [
                    { name: 'سپر ویژه', type: 'shield', description: 'افزایش زمان سپر (+8s)' },
                    { name: 'انرژی نور', type: 'score', description: 'امتیاز فوری (+400)' },
                ]
            },
            shop: {
                currency: 'توکن',
                items: [
                    { id: 'moveSpeed', name: 'سرعت حرکت', level: 0, max: 5, baseCost: 50, costMult: 1.6, effectPerLevel: { moveSpeedPct: 5 }, description: level => `افزایش سرعت حرکت (+${(level + 1) * 5}%)` },
                    { id: 'fireRate', name: 'نرخ شلیک', level: 0, max: 8, baseCost: 70, costMult: 1.6, effectPerLevel: { fireRateMult: 1.08 }, description: level => `افزایش نرخ شلیک` },
                    { id: 'bulletDamage', name: 'قدرت گلوله', level: 0, max: 7, baseCost: 80, costMult: 1.65, effectPerLevel: { dmgPct: 15 }, description: level => `افزایش آسیب گلوله (+${(level + 1) * 15}%)` },
                    { id: 'bulletSpeed', name: 'سرعت گلوله', level: 0, max: 5, baseCost: 60, costMult: 1.55, effectPerLevel: { bulletSpeedPct: 10 }, description: level => `افزایش سرعت گلوله (+${(level + 1) * 10}%)` },
                    { id: 'projectileCount', name: 'تعداد گلوله همزمان', level: 0, max: 6, baseCost: 100, costMult: 1.8, effectPerLevel: { addProjectileEvery: 2 }, description: level => `شلیک ${1 + Math.floor((level + 1) / 2)} گلوله به جای یک گلوله` },
                    { id: 'shieldDuration', name: 'مدت سپر', level: 0, max: 6, baseCost: 80, costMult: 1.7, effectPerLevel: { shieldSeconds: 2 }, description: level => `افزایش مدت زمان سپر (+${(level + 1) * 2}s)` },
                    { id: 'shieldChance', name: 'شانس سپر', level: 0, max: 5, baseCost: 90, costMult: 1.7, effectPerLevel: { addChancePct: 3 }, description: level => `افزایش شانس ظاهر شدن سپر (+${(level + 1) * 3}%)` },
                    { id: 'ammoPack', name: 'بسته گلوله', level: 0, max: 99, baseCost: 5, costMult: 1.1, effectPerLevel: { ammoAmount: 20 }, description: level => `۲۰ گلوله جدید` }
                ]
            },
            characters: [
                { id: 'default', name: 'پیش فرض', price: 0, color: '#ffcc00', owned: true },
                { id: 'red', name: 'قرمز', price: 500, color: '#f00', owned: false },
                { id: 'green', name: 'سبز', price: 750, color: '#0f0', owned: false },
                { id: 'blue', name: 'آبی', price: 1000, color: '#00f', owned: false },
            ],
            skins: [
                { id: 'default_skin', name: 'پیش فرض', price: 0, texture: null, owned: true },
                { id: 'star_skin', name: 'ستاره', price: 300, texture: null, owned: false },
                { id: 'swirl_skin', name: 'گرداب', price: 600, texture: null, owned: false },
            ],
            missions: [
                { id: 'kill10chasers', type: 'kill', enemy: 'chaser', count: 10, reward: 100, completed: false, description: 'کشتن ۱۰ دشمن تعقیب‌کننده' },
                { id: 'get500score', type: 'score', amount: 500, reward: 50, completed: false, description: 'رسیدن به امتیاز ۵۰۰' },
                { id: 'kill50enemies', type: 'kill', enemy: 'any', count: 50, reward: 150, completed: false, description: 'کشتن ۵۰ دشمن' },
            ],
            projectiles: {
                tripleShotAngle: 15,
            },
            particles: {
                playerGlowDensity: 5,
                itemGlowDensity: 3,
                maxParticles: 400,
            },
            audio: {
                ambienceVolume: 0.5,
                sfxVolume: 0.7,
                sfxUrls: {
                    pickup: 'key-176034.mp3',
                    hit: 'sfx_hurt.ogg',
                    freeze: 'coldsnap.wav',
                    slow_mo: 'coldsnap.wav',
                    ambience: '544416__zhr__background-music.mp3',
                    player_shoot: 'SHOOT007.mp3',
                    boss_hit: 'sfx_hurt.ogg',
                    boss_explosion: 'Battle in the winter.mp3',
                    boss_spawn: 'theircoming3.ogg',
                }
            },
            economy: {
                tokenName: 'توکن',
                rewards: {
                    minTokensPerWave: 6,
                    growthEvery: 3,
                    growthAmount: 1,
                    randomBonusRange: [0, 2],
                    flawlessBonus: 2,
                }
            },
            shieldSpawn: {
                cooldown: 25,
                checkInterval: 1,
                pityStep: 1.5,
                pityMax: 18,
                maxChanceCap: 40,
                baseChance: 6
            }
        };

        // Global variables, consolidated to avoid redeclaration errors
        let screenShakeX = 0;
        let screenShakeY = 0;
        const SCREEN_SHAKE_DURATION = 0.2;
        let screenShakeTime = 0;
        let musicVolume = parseFloat(localStorage.getItem('musicVolume')) || config.audio.ambienceVolume;
        let sfxVolume = parseFloat(localStorage.getItem('sfxVolume')) || config.audio.sfxVolume;
        let mouseSensitivity = parseFloat(localStorage.getItem('mouseSensitivity')) || 1.0;
        let isSlowMotion = false;
        let slowMotionTimer = 0;
        let scoreMultiplier = 1;
        
        let ownedCharacters = JSON.parse(localStorage.getItem('ownedCharacters')) || ['default'];
        let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')) || ['default_skin'];
        let selectedCharacter = localStorage.getItem('selectedCharacter') || 'default';
        let selectedSkin = localStorage.getItem('selectedSkin') || 'default_skin';
        let boss = null;
        let playerProjectiles = [];
        let playerLastShotTime = 0;
        const scoreThreshold = 1500;
        let waveTimer = 0;
        let mousePos = { x: 0, y: 0 };
        let highscore = localStorage.getItem('shadow_escape_highscore') || 0;
        let enemySpawnTimer = 0;
        let currentWaveDuration = 0;
        let missions = JSON.parse(localStorage.getItem('missions')) || config.missions.map(m => ({ ...m, completed: false }));
        
        let playerTokens = parseInt(localStorage.getItem('playerTokens')) || 0;
        let shopItems = JSON.parse(localStorage.getItem('shopItems')) || JSON.parse(JSON.stringify(config.shop.items));
        
        let timeSinceLastShield = 999;
        let pityBonus = 0;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                config.canvas.width = canvas.width;
                config.canvas.height = canvas.height;
                if (player) {
                    player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                    player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
                }
            }
        }
        window.addEventListener('resize', resizeCanvas);

        const mainMenu = document.getElementById('main-menu');
        const tutorialMenu = document.getElementById('tutorial-menu');
        const gameOverMenu = document.getElementById('game-over-menu');
        const upgradeMenu = document.getElementById('upgrade-menu');
        const missionsMenu = document.getElementById('missions-menu');
        const shopMenu = document.getElementById('shop-menu');
        const characterMenu = document.getElementById('character-menu');
        const skinsMenu = document.getElementById('skins-menu');
        const settingsMenu = document.getElementById('settings-menu');
        const hud = document.getElementById('hud');
        const comboDisplay = document.getElementById('combo-display');
        const audioToggle = document.getElementById('audio-toggle');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        // Loading overlay and spinner removed completely
        const shieldProgressBar = document.getElementById('shield-progress');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthProgress = document.getElementById('boss-health-progress');
        const waveTimerDisplay = document.getElementById('wave-timer');
        const mainContainer = document.getElementById('game-container');
        const tokenCountElement = document.getElementById('token-count');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownText = document.getElementById('countdown-text');
        
        const shootBtn = document.getElementById('shootBtn');

        let lastTime = 0;
        let gameActive = false;
        let isPaused = false;
        let flawlessWave = true;
        let player, enemies, items, particles, projectiles;
        let audioManager;
        let obstacles = [];

        window.addEventListener('load', () => {
            resizeCanvas();
            mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        });

        // =================================================================
        // Classes
        // =================================================================

        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            normalize() {
                const mag = Math.hypot(this.x, this.y);
                if (mag === 0) return this;
                this.x /= mag;
                this.y /= mag;
                return this;
            }
            scale(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }
        }

        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isDead = false;
                this.isFrozen = false;
                this.speed = config.enemies.baseSpeed;
                this.radius = config.enemies.baseRadius;
                // Changed health value for enemies to be killed with one shot
                this.health = 1; 
                this.maxHealth = 1;
                this.damageReduction = 0;
                this.isBoss = false;
                this.color = '#333';
                this.lastShotTime = 0;
                this.fireRate = 2; // bullets per second
                this.lastTeleportTime = 0;
                this.teleportCooldown = 3;
                
                // Adjust enemy speed based on wave for easier start
                const difficultyFactor = gameManager.wave === 1 ? 0.5 : 0.8 + (gameManager.wave - 1) * 0.1;
                
                switch (this.type) {
                    case 'chaser':
                        this.color = '#4a4a4a';
                        this.speed = 150 * difficultyFactor;
                        break;
                    case 'wanderer':
                        this.color = '#6b6b6b';
                        this.speed = 80 * difficultyFactor;
                        this.wanderTarget = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
                        this.changeTargetTimer = 0;
                        this.changeTargetInterval = 2;
                        break;
                    case 'shifter':
                        this.color = '#ff69b4';
                        this.speed = 180 * difficultyFactor;
                        this.shiftDirection = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
                        this.shiftDirectionTimer = 0;
                        this.shiftInterval = 0.5;
                        break;
                    case 'bomber':
                        this.color = '#f00';
                        this.speed = 100 * difficultyFactor;
                        this.radius = 20;
                        this.isExploding = false;
                        break;
                    case 'shooter':
                        this.color = '#00f';
                        this.speed = 100 * difficultyFactor;
                        break;
                    case 'splinterer':
                        this.color = '#800080';
                        this.health = 50;
                        break;
                    case 'teleporter':
                        this.color = '#9400d3';
                        this.speed = 120 * difficultyFactor;
                        this.teleportCooldown = 2;
                        break;
                    case 'armored':
                        this.color = '#a9a9a9';
                        this.health = 200;
                        this.damageReduction = 0.5;
                        break;
                    case 'pattern_shooter':
                        this.color = '#ffa500';
                        this.speed = 100 * difficultyFactor;
                        this.lastPatternShotTime = 0;
                        this.patternShotCooldown = 3;
                        break;
                    case 'boss':
                        this.isBoss = true;
                        this.speed = 70;
                        this.health = 500;
                        this.maxHealth = 500;
                        break;
                }
            }
            update(dt) {
                if (this.isFrozen) return;

                if (this.isBoss) {
                    if (player) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        this.x += (dx / dist) * this.speed * dt;
                        this.y += (dy / dist) * this.speed * dt;
                        
                        if (Date.now() - this.lastShotTime > 1000 / this.fireRate) {
                            const angleStep = Math.PI * 2 / 12;
                            for(let i = 0; i < 12; i++) {
                                const angle = i * angleStep;
                                const direction = new Vector(Math.cos(angle), Math.sin(angle));
                                projectiles.push(new Projectile(this.x, this.y, direction, 200));
                            }
                            this.lastShotTime = Date.now();
                            if (audioManager) audioManager.playSfx('boss_hit');
                        }
                    }
                } else {
                    // Regular enemy movement
                    if (player) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.hypot(dx, dy);

                        if (this.type === 'chaser') {
                             this.x += (dx / dist) * this.speed * dt;
                             this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'wanderer') {
                             this.changeTargetTimer += dt;
                             if (this.changeTargetTimer > this.changeTargetInterval) {
                                 this.wanderTarget = {x: Math.random() * canvas.width, y: Math.random() * canvas.height};
                                 this.changeTargetTimer = 0;
                             }
                             const targetDx = this.wanderTarget.x - this.x;
                             const targetDy = this.wanderTarget.y - this.y;
                             const targetDist = Math.hypot(targetDx, targetDy);
                             this.x += (targetDx / targetDist) * this.speed * dt;
                             this.y += (targetDy / targetDist) * this.speed * dt;
                        } else if (this.type === 'shifter') {
                             this.shiftDirectionTimer += dt;
                             if (this.shiftDirectionTimer > this.shiftInterval) {
                                 this.shiftDirection = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
                                 const len = Math.hypot(this.shiftDirection.x, this.shiftDirection.y);
                                 this.shiftDirection.x /= len;
                                 this.shiftDirection.y /= len;
                                 this.shiftDirectionTimer = 0;
                             }
                             this.x += this.shiftDirection.x * this.speed * dt;
                             this.y += this.shiftDirection.y * this.speed * dt;
                        } else if (this.type === 'bomber') {
                            if (dist < 100) {
                                if (!this.isExploding) {
                                    this.isExploding = true;
                                    setTimeout(() => {
                                        enemies = enemies.filter(e => e !== this);
                                        const explosionRadius = 100;
                                        const explosionDamage = 50;
                                        for (const otherEnemy of enemies) {
                                            const exDist = Math.hypot(this.x - otherEnemy.x, this.y - otherEnemy.y);
                                            if (exDist < explosionRadius) {
                                                otherEnemy.health -= explosionDamage;
                                            }
                                        }
                                        startScreenShake();
                                        if (audioManager) audioManager.playSfx('hit');
                                    }, 1000);
                                }
                            } else {
                                this.x += (dx / dist) * this.speed * dt;
                                this.y += (dy / dist) * this.speed * dt;
                            }
                        } else if (this.type === 'shooter') {
                            if (dist > 200) {
                                this.x += (dx / dist) * this.speed * dt;
                                this.y += (dy / dist) * this.speed * dt;
                            }
                            if (Date.now() - this.lastShotTime > 1000 / this.fireRate) {
                                const direction = new Vector(dx, dy).normalize();
                                projectiles.push(new Projectile(this.x, this.y, direction, 200));
                                this.lastShotTime = Date.now();
                                if (audioManager) audioManager.playSfx('hit');
                            }
                        } else if (this.type === 'splinterer') {
                             this.x += (dx / dist) * this.speed * dt;
                             this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'teleporter') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                            this.lastTeleportTime += dt;
                            if (this.lastTeleportTime > this.teleportCooldown) {
                                this.x = Math.random() * canvas.width;
                                this.y = Math.random() * canvas.height;
                                this.lastTeleportTime = 0;
                            }
                        } else if (this.type === 'armored') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                        } else if (this.type === 'pattern_shooter') {
                            this.x += (dx / dist) * this.speed * dt;
                            this.y += (dy / dist) * this.speed * dt;
                            this.lastPatternShotTime += dt;
                            if (this.lastPatternShotTime > this.patternShotCooldown) {
                                const numBullets = 8;
                                for (let i = 0; i < numBullets; i++) {
                                    const angle = (i * Math.PI * 2) / numBullets;
                                    const direction = new Vector(Math.cos(angle), Math.sin(angle));
                                    projectiles.push(new Projectile(this.x, this.y, direction, 200));
                                }
                                this.lastPatternShotTime = 0;
                            }
                        }
                    }
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;

                if (this.isFrozen) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                if (this.isBoss) {
                    ctx.fillStyle = '#f00';
                    ctx.font = '20px Vazirmatn';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('BOSS', this.x, this.y);
                }
            }
        }
        
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.type = type;
                this.color = '#fff';
                this.isDead = false;

                switch (type) {
                    case 'shield':
                        this.color = '#00aaff';
                        break;
                    case 'freeze':
                        this.color = '#00ffff';
                        break;
                    case 'crystal':
                        this.color = '#ffcc00';
                        break;
                    case 'slow_mo':
                        this.color = '#ff00ff';
                        break;
                    case 'double_score':
                        this.color = '#ffaa00';
                        break;
                    case 'ammo':
                        this.color = '#fff';
                        break;
                    case 'token': // New token item type
                        this.color = '#ff0000';
                        break;
                }
            }
            update(dt) {
                // Items don't move, but we can add effects
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.velocity = velocity;
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.isDead = false;
            }
            update(dt) {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.life -= dt;
                if (this.life <= 0) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            reset(x, y, velocity, color, radius, life) {
                this.x = x;
                this.y = y;
                this.velocity = velocity;
                this.color = color;
                this.radius = radius;
                this.life = life;
                this.isDead = false;
            }
        }

        const particlePool = [];
        let particlePoolIndex = 0;
        function getParticle(x, y, velocity, color, radius, life) {
            if (particlePool.length < config.particles.maxParticles) {
                const newParticle = new Particle(x, y, velocity, color, radius, life);
                particlePool.push(newParticle);
                return newParticle;
            } else {
                const particle = particlePool[particlePoolIndex];
                particle.reset(x, y, velocity, color, radius, life);
                particlePoolIndex = (particlePoolIndex + 1) % config.particles.maxParticles;
                return particle;
            }
        }
        
        class Projectile {
            constructor(x, y, direction, speed) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = speed;
                this.radius = 5;
                this.color = '#ff0000';
                this.isDead = false;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        class PlayerProjectile {
            constructor(x, y, direction, damage) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = config.player.projectileSpeed;
                this.radius = 3;
                this.color = '#fff';
                this.isDead = false;
                // Changed damage value so one shot is enough to kill an enemy
                this.damage = 1;
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                
                // Check for collision with enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < this.radius + enemy.radius) {
                        enemy.health -= this.damage;
                        this.isDead = true; // Mark projectile for removal
                        if (enemy.health <= 0) {
                            enemy.isDead = true; // Mark enemy for removal
                            gameManager.score += 50; // Add score for killing an enemy
                            gameManager.updateMissions("kill", enemy.type, 1);
                        }
                        break;
                    }
                }
                
                if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = '#ffcc00';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        class TripleShotProjectile extends PlayerProjectile {
             constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#ffcc00';
                this.radius = 4;
            }
        }
        
        class LaserProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.length = 200;
                this.width = 5;
                this.color = '#0f0';
                this.isDead = false;
                this.hitEnemies = new Set();
            }
            update(dt) {
                this.x += this.direction.x * this.speed * dt;
                this.y += this.direction.y * this.speed * dt;
                if (this.x < -this.length || this.x > canvas.width + this.length || this.y < -this.length || this.y > canvas.height + this.length) {
                    this.isDead = true;
                }
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const angle = Math.atan2(this.direction.y, this.direction.x);
                ctx.rotate(angle);
                
                const gradient = ctx.createLinearGradient(0, -this.width/2, this.length, this.width/2);
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, -this.width/2, this.length, this.width);
                ctx.restore();
            }
        }
        
        class BombProjectile extends PlayerProjectile {
            constructor(x, y, direction, damage) {
                super(x, y, direction, damage);
                this.color = '#f00';
                this.radius = 8;
                this.isExploded = false;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 100;
                this.explosionDuration = 0.3;
                this.explosionTimer = 0;
            }
            update(dt) {
                if (this.isExploded) {
                    this.explosionTimer += dt;
                    this.explosionRadius = (this.explosionTimer / this.explosionDuration) * this.maxExplosionRadius;
                    if (this.explosionTimer >= this.explosionDuration) {
                        this.isDead = true;
                    }
                } else {
                    this.x += this.direction.x * this.speed * dt;
                    this.y += this.direction.y * this.speed * dt;
                    for (const enemy of enemies) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < this.radius + enemy.radius) {
                            this.isExploded = true;
                            break;
                        }
                    }
                }
            }
            draw(ctx) {
                if (this.isExploded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.explosionRadius, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.explosionRadius);
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                } else {
                    super.draw(ctx);
                }
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = config.player.radius;
                this.isInvincible = false;
                this.combo = 0;
                this.comboBonus = 0;
                this.comboMultiplier = 1;
                this.targetSpeed = this.speed;
                this.deathTimer = 0;
                this.originalSpeed = this.speed;
                this.shieldEffectTimer = 0;
                this.isShieldActive = false;
                this.shieldTime = 0;
                this.maxShieldTime = config.player.shieldTime;
                this.isShooting = false;
                this.shootCooldown = 0;
                this.projectileType = 'basic';
                this.ammo = config.player.maxAmmo;
                
                const char = config.characters.find(c => c.id === selectedCharacter);
                this.color = char ? char.color : config.player.glowColor;
                
                this.applyUpgrades();
            }
            
            applyUpgrades() {
                const getLevel = id => shopItems.find(i => i.id === id)?.level || 0;
                
                this.speed = config.player.baseSpeed * (1 + getLevel('moveSpeed') * config.shop.items.find(i => i.id === 'moveSpeed').effectPerLevel.moveSpeedPct / 100);
                this.fireRate = config.player.baseFireRate * Math.pow(1 + config.shop.items.find(i => i.id === 'fireRate').effectPerLevel.fireRateMult / 100, getLevel('fireRate'));
                this.damage = config.player.baseDamage * (1 + getLevel('bulletDamage') * config.shop.items.find(i => i.id === 'bulletDamage').effectPerLevel.dmgPct / 100);
                this.projectileSpeed = config.player.projectileSpeed * (1 + getLevel('bulletSpeed') * config.shop.items.find(i => i.id === 'bulletSpeed').effectPerLevel.bulletSpeedPct / 100);
                this.projectileCount = 1 + Math.floor(getLevel('projectileCount') / config.shop.items.find(i => i.id === 'projectileCount').effectPerLevel.addProjectileEvery);
                this.maxShieldTime = config.player.shieldTime + getLevel('shieldDuration') * config.shop.items.find(i => i.id === 'shieldDuration').effectPerLevel.shieldSeconds;
                this.shieldChanceBase = config.shieldSpawn.baseChance + getLevel('shieldChance') * config.shop.items.find(i => i.id === 'shieldChance').effectPerLevel.addChancePct;
            }

            setProjectileType(type) {
                this.projectileType = type;
            }

            shoot() {
                if (this.shootCooldown <= 0 && this.ammo > 0) {
                    const dx = mousePos.x - this.x;
                    const dy = mousePos.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    const direction = {x: dx/dist, y: dy/dist};
                    
                    for (let i = 0; i < this.projectileCount; i++) {
                        const angleSpread = config.projectiles.tripleShotAngle * Math.PI / 180;
                        const baseAngle = Math.atan2(direction.y, direction.x);
                        const angleOffset = (i - (this.projectileCount - 1) / 2) * (angleSpread / (this.projectileCount > 1 ? this.projectileCount - 1 : 1));
                        const shotAngle = baseAngle + angleOffset;

                        const projectileDirection = {
                            x: Math.cos(shotAngle),
                            y: Math.sin(shotAngle)
                        };
                        
                        playerProjectiles.push(new PlayerProjectile(this.x, this.y, projectileDirection, this.damage));
                    }

                    this.ammo--;
                    this.shootCooldown = 1 / this.fireRate;
                    if (audioManager) audioManager.playSfx('player_shoot');
                }
            }

            update(dt, inputVector) {
                this.shootCooldown -= dt;
                if (this.isShooting && this.shootCooldown <= 0 && this.ammo > 0) {
                    this.shoot();
                }
                
                this.targetSpeed = this.speed;

                const previousShieldState = this.isShieldActive;
                this.isShieldActive = this.shieldTime > 0;
                if (this.isShieldActive) {
                    this.shieldTime -= dt;
                    if (this.shieldTime < 0) this.shieldTime = 0;
                    this.shieldEffectTimer += dt;
                    if (this.shieldEffectTimer > 0.1) {
                        for (let i = 0; i < 3; i++) {
                            const ang = Math.random() * Math.PI * 2;
                            const dist = this.radius * 2;
                            particles.push(getParticle(
                                this.x + Math.cos(ang) * dist,
                                this.y + Math.sin(ang) * dist,
                                { x: Math.cos(ang) * 0.5, y: Math.sin(ang) * 0.5 },
                                '#00ffff',
                                Math.random() * 2 + 1,
                                0.5
                            ));
                        }
                        this.shieldEffectTimer = 0;
                    }
                }

                const progress = this.maxShieldTime > 0 ? (this.shieldTime / this.maxShieldTime) * 100 : 0;
                if (shieldProgressBar) shieldProgressBar.style.width = `${progress}%`;

                if (inputVector && (inputVector.x !== 0 || inputVector.y !== 0)) {
                    this.x += inputVector.x * this.speed * dt;
                    this.y += inputVector.y * this.speed * dt;
                }

                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                if (particles.length < config.particles.maxParticles) {
                    const spawnCount = Math.max(1, Math.round(config.particles.playerGlowDensity / 2));
                    for (let i = 0; i < spawnCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * this.radius * 0.5;
                        particles.push(getParticle(
                            this.x + Math.cos(angle) * r,
                            this.y + Math.sin(angle) * r,
                            { x: Math.cos(angle), y: Math.sin(angle) },
                            this.color,
                            Math.random() * 2 + 1,
                            0.5
                        ));
                    }
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                if (player && player.color) {
                    const gradient = ctx.createRadialGradient(this.x, this.y, this.radius, this.x, this.y, this.radius * 2);
                    const rgbColor = hexToRgb(this.color);
                    if (rgbColor) {
                        gradient.addColorStop(0, `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, ${this.shieldTime > 0 ? 0.3 : 0.2})`);
                    } else {
                        gradient.addColorStop(0, `rgba(255, 255, 255, ${this.shieldTime > 0 ? 0.3 : 0.2})`);
                    }
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.shieldTime > 0) {
                    const shieldGradient = ctx.createRadialGradient(this.x, this.y, this.radius * 1.5, this.x, this.y, this.radius * 1.8);
                    shieldGradient.addColorStop(0, 'rgba(0, 255, 128, 0.5)'); // Green shield
                    shieldGradient.addColorStop(1, 'rgba(0, 255, 128, 0)');
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Obstacle {
            constructor(x, y, width, height, isMovable = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isMovable = isMovable;
                this.color = '#1a1a1a';
                this.direction = {x: 0, y: 0};
                if (isMovable) {
                    const ang = Math.random() * Math.PI * 2;
                    this.direction = {x: Math.cos(ang), y: Math.sin(ang)};
                }
            }

            update(dt) {
                if (this.isMovable) {
                    this.x += this.direction.x * 50 * dt;
                    this.y += this.direction.y * 50 * dt;

                    if (this.x < 0 || this.x + this.width > canvas.width) {
                        this.direction.x *= -1;
                    }
                    if (this.y < 0 || this.y + this.height > canvas.height) {
                        this.direction.y *= -1;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // =================================================================
        // Functions
        // =================================================================

        const inputManager = {
            keys: {},
            lastMoveTime: 0,
            init() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.key.toLowerCase() === 'w' || e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 's' || e.key.toLowerCase() === 'd' ||
                        e.key.toLowerCase() === 'arrowup' || e.key.toLowerCase() === 'arrowleft' || e.key.toLowerCase() === 'arrowdown' || e.key.toLowerCase() === 'arrowright') {
                        e.preventDefault();
                    }
                    
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.code === 'Space') {
                        if (gameActive && player) {
                            player.isShooting = true;
                        }
                    }
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    if (e.code === 'Space') {
                        if (player) player.isShooting = false;
                    }
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (gameActive) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.clientX - rect.left) * scaleX;
                        mousePos.y = (e.clientY - rect.top) * scaleY;
                    }
                });
                canvas.addEventListener('touchmove', (e) => {
                    if (e.cancelable) e.preventDefault();
                    if (gameActive && e.touches.length > 0) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        mousePos.x = (e.touches[0].clientX - rect.left) * scaleX;
                        mousePos.y = (e.touches[0].clientY - rect.top) * scaleY;
                    }
                }, { passive: false });
                canvas.addEventListener('mousedown', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                });
                canvas.addEventListener('mouseup', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
                canvas.addEventListener('touchstart', (e) => {
                    if (gameActive && player) {
                        player.isShooting = true;
                    }
                }, { passive: false });
                canvas.addEventListener('touchend', (e) => {
                    if (gameActive && player) {
                        player.isShooting = false;
                    }
                });
            },
            getMovementVector() {
                const vector = { x: 0, y: 0 };
                const keyboardActive = this.keys['w'] || this.keys['a'] || this.keys['s'] || this.keys['d'] ||
                                      this.keys['arrowup'] || this.keys['arrowleft'] || this.keys['arrowdown'] || this.keys['arrowright'];

                if (keyboardActive) {
                    if (this.keys['w'] || this.keys['arrowup']) vector.y = -1;
                    if (this.keys['s'] || this.keys['arrowdown']) vector.y = 1;
                    if (this.keys['a'] || this.keys['arrowleft']) vector.x = -1;
                    if (this.keys['d'] || this.keys['arrowright']) vector.x = 1;

                    const len = Math.hypot(vector.x, vector.y);
                    if (len > 0) { vector.x /= len; vector.y /= len; }
                } else {
                    if (player) {
                        const dx = mousePos.x - player.x;
                        const dy = mousePos.y - player.y;
                        const dist = Math.hypot(dx, dy);
                        // Changed dist threshold from 10 to 1 for smoother movement
                        if (dist > 1) {
                            vector.x = dx / dist;
                            vector.y = dy / dist;
                        }
                    }
                }
                return vector;
            }
        };

        class AudioManager {
            constructor() {
                this.isInitialized = false;
                this.isMuted = false;
                this.ambience = null;
                this.sfx = {};
                this.sfxUrls = config.audio.sfxUrls;
            }

            async loadAudioAsBlob(url, vol=1) {
                try {
                    const res = await fetch(url, { mode:'cors', referrerPolicy:'no-referrer' });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const blob = await res.blob();
                    const a = new Audio(URL.createObjectURL(blob));
                    a.volume = vol;
                    return a;
                } catch (e) {
                    console.warn('audio load failed:', url, e);
                    return null;
                }
            }
            
            async init() {
                if (this.isInitialized) return;
                this.isInitialized = true;
                
                this.ambience = await this.loadAudioAsBlob(this.sfxUrls.ambience, musicVolume);
                if (this.ambience) {
                    this.ambience.loop = true;
                }

                for (const key of Object.keys(this.sfxUrls).filter(k => k !== 'ambience')) {
                    this.sfx[key] = await this.loadAudioAsBlob(this.sfxUrls[key], sfxVolume);
                }
            }


            updateVolumes(newMusicVolume, newSfxVolume) {
                musicVolume = newMusicVolume;
                sfxVolume = newSfxVolume;
                if (this.ambience) {
                    this.ambience.volume = musicVolume;
                }
                for (const key in this.sfx) {
                    if (this.sfx[key]) {
                        this.sfx[key].volume = sfxVolume;
                    }
                }
                localStorage.setItem('musicVolume', musicVolume);
                localStorage.setItem('sfxVolume', sfxVolume);
            }

            playAmbience() {
                if (this.ambience && !this.isMuted) {
                    this.ambience.play().catch(e => console.log('Ambience playback blocked:', e));
                }
            }
            pauseAmbience() {
                if (this.ambience) {
                    this.ambience.pause();
                }
            }
            playSfx(name) {
                if (!this.isInitialized || this.isMuted) return;
                const sfx = this.sfx[name];
                if (sfx) {
                    const clonedSfx = sfx.cloneNode();
                    clonedSfx.volume = sfx.volume;
                    clonedSfx.play().catch(e => console.log('SFX playback blocked:', e));
                }
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.isMuted) {
                    this.pauseAmbience();
                    audioToggle.textContent = '';
                } else {
                    this.playAmbience();
                    audioToggle.textContent = '🔊';
                }
            }
        }
        

        const gameManager = {
            score: 0,
            wave: 1,
            isWaveActive: false,
            waveStartTime: 0,
            init() {
                this.score = 0;
                this.wave = 1;
                this.isWaveActive = false;
                this.waveStartTime = 0;
                enemies = [];
                items = [];
                particles = [];
                projectiles = [];
                playerProjectiles = [];
                enemySpawnTimer = 0;
                currentWaveDuration = 0;
                obstacles = [];
                flawlessWave = true;
                
                missions = config.missions.map(m => ({ ...m, completed: false }));
                localStorage.setItem('missions', JSON.stringify(missions));
                
                player = new Player(canvas.width / 2, canvas.height / 2);
                this.updateHUD();
            },
            updateHUD() {
                const scoreElement = document.getElementById('score');
                const waveElement = document.getElementById('wave');
                const shieldElement = document.getElementById('shield-time');
                const ammoElement = document.getElementById('ammo-count');
                const tokenCountElement = document.getElementById('token-count');

                if (scoreElement) scoreElement.textContent = Math.round(this.score);
                if (waveElement) waveElement.textContent = this.wave;
                if (player && shieldElement) {
                    shieldElement.textContent = player.shieldTime > 0 ? player.shieldTime.toFixed(1) : '0';
                    const progress = player.maxShieldTime > 0 ? (player.shieldTime / player.maxShieldTime) * 100 : 0;
                    if (shieldProgressBar) shieldProgressBar.style.width = `${progress}%`;
                }
                if (player && ammoElement) ammoElement.textContent = player.ammo;
                if (tokenCountElement) tokenCountElement.innerHTML = `${playerTokens} <span class="token-icon-hud">💰</span>`;
                
                if (shootBtn) {
                    if (player && player.ammo <= 0) {
                        shootBtn.style.opacity = 0.5;
                        shootBtn.style.cursor = 'not-allowed';
                    } else {
                        shootBtn.style.opacity = 1;
                        shootBtn.style.cursor = 'pointer';
                    }
                }

                if (boss) {
                    if (bossHealthBar) bossHealthBar.style.opacity = 1;
                    const progress = (boss.health / boss.maxHealth) * 100;
                    if (bossHealthProgress) bossHealthProgress.style.width = `${progress}%`;
                } else {
                    if (bossHealthBar) bossHealthBar.style.opacity = 0;
                }
            },
            updateMissions(type, enemyType = null, amount = 0) {
                missions.forEach(mission => {
                    if (mission.completed) return;
                    
                    if (mission.type === 'kill' && type === 'kill') {
                        if (mission.enemy === 'any' || mission.enemy === enemyType) {
                            mission.count--;
                            if (mission.count <= 0) {
                                mission.completed = true;
                                this.score += mission.reward;
                                showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                            }
                        }
                    } else if (mission.type === 'score' && type === 'score') {
                        if (this.score >= mission.amount) {
                            mission.completed = true;
                            this.score += mission.reward;
                            showMessage(`ماموریت تکمیل شد! <br> ${mission.description}`);
                        }
                    }
                });
                localStorage.setItem('missions', JSON.stringify(missions));
            },
            startWave() {
                this.isWaveActive = true;
                currentWaveDuration = config.waves.waveDuration + this.wave * config.waves.waveDurationGrowth;
                enemySpawnTimer = 0;
                flawlessWave = true;
                
                player.isShieldActive = false;
                player.shieldTime = 0;

                // Spawns enemies for the current wave based on the wave number
                this.spawnEnemiesForWave(this.wave);
            },
            spawnBoss() {
                boss = new Enemy(canvas.width / 2, -100, 'boss');
                boss.maxHealth = 500;
                boss.health = 500;
                boss.color = '#ff0000';
                boss.radius = 40;
                enemies.push(boss);
                if (audioManager) audioManager.playSfx('boss_spawn');
            },
            spawnEnemiesForWave(wave) {
                let enemyTypesToSpawn = [];
                let enemyCount = 0;

                if (wave === 1) {
                    enemyTypesToSpawn = ['chaser'];
                    enemyCount = 2; // Easier start
                } else if (wave === 2) {
                    enemyTypesToSpawn = ['chaser', 'wanderer'];
                    enemyCount = 4;
                } else if (wave === 3) {
                    enemyTypesToSpawn = ['chaser', 'wanderer', 'shooter'];
                    enemyCount = 6;
                } else if (wave === 4) {
                    enemyTypesToSpawn = ['chaser', 'wanderer', 'shooter', 'teleporter'];
                    enemyCount = 8;
                } else if (wave % 5 === 0) {
                    this.spawnBoss();
                    return;
                } else {
                    enemyTypesToSpawn = ['chaser', 'wanderer', 'shifter', 'bomber', 'shooter', 'splinterer', 'teleporter', 'armored', 'pattern_shooter'];
                    enemyCount = 10 + Math.floor(wave / 2);
                }

                for (let i = 0; i < enemyCount; i++) {
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (side) {
                        case 0: x = -config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 1: x = canvas.width + config.enemies.spawnDistance; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = -config.enemies.spawnDistance; break;
                        case 3: x = Math.random() * canvas.width; y = canvas.height + config.enemies.spawnDistance; break;
                    }
                    const type = enemyTypesToSpawn[Math.floor(Math.random() * enemyTypesToSpawn.length)];
                    enemies.push(new Enemy(x, y, type));
                }
            },
            spawnItems() {
                if (Math.random() < config.items.spawnRate) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const rand = Math.random();
                    let itemType;
                    const raritySum = Object.values(config.items.rarity).reduce((a, b) => a + b, 0);
                    let cumulativeRarity = 0;
                    for (const key in config.items.rarity) {
                        cumulativeRarity += config.items.rarity[key];
                        if (rand < cumulativeRarity) {
                            itemType = key;
                            break;
                        }
                    }
                    items.push(new Item(x, y, itemType));
                }
            },
            giveWaveTokens() {
                let baseTokens = config.economy.rewards.minTokensPerWave;
                for (let i = 0; i < baseTokens; i++) {
                    const color = (i % 2 === 0) ? "#f00" : "#00f";
                    const item = new Item(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        "token"
                    );
                    item.color = color;
                    items.push(item);
                }
            },
            tokensForWaveEnd() {
                const { minTokensPerWave, growthEvery, growthAmount, randomBonusRange, flawlessBonus } = config.economy.rewards;
                const base = minTokensPerWave;
                const growth = Math.floor(this.wave / growthEvery) * growthAmount;
                const rng = Math.floor(Math.random() * (randomBonusRange[1] - randomBonusRange[0] + 1)) + randomBonusRange[0];
                return base + growth + rng + (flawlessWave ? flawlessBonus : 0);
            },
            startWaveCountdown() {
                isPaused = true;
                hideAllPanels();
                if (countdownOverlay) countdownOverlay.classList.add('visible');

                let count = 3;
                if (countdownText) countdownText.textContent = count;

                const countdownInterval = setInterval(() => {
                    count--;
                    if (countdownText) countdownText.textContent = count > 0 ? count : 'GO!';
                    if (count < 0) {
                        clearInterval(countdownInterval);
                        if (countdownOverlay) countdownOverlay.classList.remove('visible');
                        gameActive = true;
                        isPaused = false;
                        this.startWave();
                    }
                }, 1000);
            },
            showUpgradeScreen() {
                isPaused = true;
                hideAllPanels();
                if (upgradeMenu) upgradeMenu.classList.add('visible');
                const upgradeOptionsDiv = document.getElementById('upgrade-options');
                if (!upgradeOptionsDiv) return;
                
                upgradeOptionsDiv.innerHTML = '';
                
                const projectileUpgradeOption = {
                    name: 'شلیک سه‌تایی',
                    description: 'شلیک سه تیر به جای یک تیر با زاویه ±۱۵ درجه',
                    effect: (player) => player.setProjectileType('triple')
                };
                
                const availableUpgrades = [...config.upgrades.options, projectileUpgradeOption];
                
                for (let i = 0; i < config.upgrades.optionCount; i++) {
                    if (availableUpgrades.length === 0) break;
                    const randomIndex = Math.floor(Math.random() * availableUpgrades.length);
                    const upgrade = availableUpgrades.splice(randomIndex, 1)[0];

                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    card.innerHTML = `<h3>${upgrade.name}</h3><p>${upgrade.description}</p>`;
                    card.addEventListener('click', () => {
                        upgrade.effect(player);
                        const tokensEarned = this.tokensForWaveEnd();
                        playerTokens += tokensEarned;
                        localStorage.setItem('playerTokens', playerTokens);
                        showMessage(`پایان موج! شما ${tokensEarned} توکن کسب کردید.`);
                        this.wave++;
                        this.startWaveCountdown();
                    });
                    upgradeOptionsDiv.appendChild(card);
                }
            },
            showShopScreen() {
                isPaused = true;
                hideAllPanels();
                if (shopMenu) shopMenu.classList.add('half-visible');
                const shopItemsDiv = document.getElementById('shop-items');
                if (!shopItemsDiv) return;
                shopItemsDiv.innerHTML = '';
                
                const shopTokens = document.getElementById('shop-tokens');
                if (shopTokens) shopTokens.textContent = playerTokens;

                shopItems.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    
                    const isMaxLevel = item.level >= item.max;
                    const price = Math.round(item.baseCost * Math.pow(item.costMult, item.level));
                    const canAfford = playerTokens >= price;
                    
                    const descriptionText = typeof item.description === 'function' ? item.description(item.level) : item.description;

                    card.innerHTML = `
                        <h3>${item.name}</h3>
                        <p>${descriptionText}</p>
                        <span class="price">${isMaxLevel ? 'حداکثر' : price} <span class="token-icon">💰</span></span>
                        <span class="level">سطح: ${item.level} / ${item.max}</span>
                    `;

                    if (isMaxLevel || !canAfford) {
                        card.classList.add('purchased');
                        card.style.cursor = 'not-allowed';
                    }

                    card.addEventListener('click', () => {
                        if (isMaxLevel || !canAfford) return;

                        playerTokens -= price;
                        item.level++;
                        player.applyUpgrades();

                        localStorage.setItem('playerTokens', playerTokens);
                        localStorage.setItem('shopItems', JSON.stringify(shopItems));
                        
                        this.showShopScreen();
                    });
                    
                    shopItemsDiv.appendChild(card);
                });
            },
            showCharacterMenu() {
                isPaused = true;
                hideAllPanels();
                if (characterMenu) characterMenu.classList.add('half-visible');
                const characterOptionsDiv = document.getElementById('character-options');
                if (!characterOptionsDiv) return;
                characterOptionsDiv.innerHTML = '';
                
                config.characters.forEach(char => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.innerHTML = `<h3>${char.name}</h3><p>شخصیت جدید</p><span class="price">${char.price}</span>`;
                    
                    const isOwned = ownedCharacters.includes(char.id);
                    if (isOwned) {
                        card.classList.add('owned');
                        if (selectedCharacter === char.id) {
                            card.innerHTML = `<h3>${char.name}</h3><p>شخصیت فعلی</p><span class="status">فعال</span>`;
                            card.style.cursor = 'not-allowed';
                        } else {
                            card.innerHTML = `<h3>${char.name}</h3><p>شخصیت جدید</p><span class="status">انتخاب</span>`;
                            card.addEventListener('click', () => {
                                selectedCharacter = char.id;
                                localStorage.setItem('selectedCharacter', selectedCharacter);
                                if (player) player.color = char.color;
                                this.showCharacterMenu();
                            });
                        }
                    } else {
                        card.addEventListener('click', () => {
                            if (playerTokens >= char.price) {
                                playerTokens -= char.price;
                                ownedCharacters.push(char.id);
                                localStorage.setItem('ownedCharacters', JSON.stringify(ownedCharacters));
                                localStorage.setItem('playerTokens', playerTokens);
                                this.showCharacterMenu();
                            } else {
                                showMessage('توکن کافی برای خرید این شخصیت ندارید.');
                            }
                        });
                    }
                    characterOptionsDiv.appendChild(card);
                });
            },
            showSkinsMenu() {
                isPaused = true;
                hideAllPanels();
                if (skinsMenu) skinsMenu.classList.add('half-visible');
                const skinsOptionsDiv = document.getElementById('skins-options');
                if (!skinsOptionsDiv) return;
                skinsOptionsDiv.innerHTML = '';
                
                config.skins.forEach(skin => {
                    const card = document.createElement('div');
                    card.className = 'shop-item';
                    card.innerHTML = `<h3>${skin.name}</h3><p>اسکین جدید</p><span class="price">${skin.price}</span>`;
                    
                    const isOwned = ownedSkins.includes(skin.id);
                    if (isOwned) {
                        card.classList.add('owned');
                        if (selectedSkin === skin.id) {
                            card.innerHTML = `<h3>${skin.name}</h3><p>اسکین فعلی</p><span class="status">فعال</span>`;
                            card.style.cursor = 'not-allowed';
                        } else {
                            card.innerHTML = `<h3>${skin.name}</h3><p>اسکین جدید</p><span class="status">انتخاب</span>`;
                            card.addEventListener('click', () => {
                                selectedSkin = skin.id;
                                localStorage.setItem('selectedSkin', selectedSkin);
                                this.showSkinsMenu();
                            });
                        }
                    } else {
                        card.addEventListener('click', () => {
                            if (playerTokens >= skin.price) {
                                playerTokens -= skin.price;
                                ownedSkins.push(skin.id);
                                localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins));
                                localStorage.setItem('playerTokens', playerTokens);
                                this.showSkinsMenu();
                            } else {
                                showMessage('توکن کافی برای خرید این اسکین ندارید.');
                            }
                        });
                    }
                    skinsOptionsDiv.appendChild(card);
                });
            },
            showMissionsScreen() {
                isPaused = true;
                hideAllPanels();
                if (missionsMenu) missionsMenu.classList.add('half-visible');
                const missionsListDiv = document.getElementById('missions-list');
                if (!missionsListDiv) return;
                missionsListDiv.innerHTML = '';

                missions.forEach(mission => {
                    const card = document.createElement('div');
                    card.className = 'mission-item';
                    card.innerHTML = `<h3>${mission.description}</h3><span class="status">${mission.completed ? 'تکمیل شد' : 'در حال انجام'}</span>`;
                    if (mission.completed) {
                        card.classList.add('completed');
                    }
                    missionsListDiv.appendChild(card);
                });
            },
        };

        function startScreenShake() {
            screenShakeTime = SCREEN_SHAKE_DURATION;
        }

        function hideAllPanels() {
          [
            mainMenu, tutorialMenu, gameOverMenu, upgradeMenu,
            missionsMenu, shopMenu, characterMenu, skinsMenu, settingsMenu, hud, countdownOverlay
          ].filter(Boolean)
           .forEach(panel => panel.classList.remove('visible', 'half-visible'));
        }

        function showPanel(panel) {
          hideAllPanels();
          if (panel) panel.classList.add('visible');
        }

        // New showMessage function with auto-hide feature
        function showMessage(text) {
            if (messageText) messageText.innerHTML = text;
            if (messageBox) {
                messageBox.classList.add('visible');
                clearTimeout(messageBox.hideTimeout);
                messageBox.hideTimeout = setTimeout(() => {
                    messageBox.classList.remove('visible');
                }, 5000);
            }
        }

        function startGame() {
            gameManager.init();
            hideAllPanels();
            gameManager.startWaveCountdown();
            if (audioManager && audioManager.isInitialized) {
                audioManager.playAmbience();
            }
        }

        function handleCollisions() {
            if (!player) return;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + enemy.radius + config.player.comboNearMissDistance) {
                    if (comboDisplay && Math.random() < 0.005) {
                        player.combo++;
                        player.comboBonus += player.combo * config.player.comboBonusMultiplier;
                        comboDisplay.textContent = `Combo! x${player.combo}`;
                        comboDisplay.style.opacity = 1;
                        setTimeout(() => { if (comboDisplay) comboDisplay.style.opacity = 0; }, 500);
                    }
                }

                if (distance < player.radius + enemy.radius) {
                    if (player.shieldTime > 0) {
                        player.shieldTime--;
                        gameManager.score += 10;
                        if (enemy.type === 'splinterer') {
                             for (let j = 0; j < 3; j++) {
                                const ang = Math.random() * Math.PI * 2;
                                enemies.push(new Enemy(enemy.x, enemy.y, 'chaser'));
                             }
                        }
                        gameManager.updateMissions('kill', enemy.type);
                        enemies.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                        flawlessWave = false;
                    } else {
                        endGame();
                        return;
                    }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                const dx = player.x - projectile.x;
                const dy = player.y - projectile.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + projectile.radius) {
                    if (player.shieldTime > 0) {
                        player.shieldTime--;
                        projectiles.splice(i, 1);
                        if (audioManager) audioManager.playSfx('hit');
                        startScreenShake();
                        flawlessWave = false;
                    } else {
                        endGame();
                        return;
                    }
                }
            }
            
            for (const obstacle of obstacles) {
                const dx = player.x - Math.max(obstacle.x, Math.min(player.x, obstacle.x + obstacle.width));
                const dy = player.y - Math.max(obstacle.y, Math.min(player.y, obstacle.y + obstacle.height));
                if (Math.hypot(dx, dy) < player.radius) {
                    endGame();
                    return;
                }
            }

            // Moved projectile collision logic to PlayerProjectile.update() to handle damage and death
            
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.hypot(dx, dy);

                if (distance < player.radius + item.radius) {
                    switch (item.type) {
                        case 'shield':
                            if (player) {
                                player.shieldTime += 3;
                                player.maxShieldTime += 3;
                            }
                            break;
                        case 'freeze':
                            enemies.forEach(e => {
                                e.isFrozen = true;
                                setTimeout(() => e.isFrozen = false, 2000);
                            });
                            if (audioManager) audioManager.playSfx('freeze');
                            break;
                        case 'crystal':
                            gameManager.score += 25;
                            break;
                        case 'slow_mo':
                            isSlowMotion = true;
                            slowMotionTimer = 4;
                            if (audioManager) audioManager.playSfx('slow_mo');
                            break;
                        case 'double_score':
                            scoreMultiplier = 2;
                            setTimeout(() => scoreMultiplier = 1, 8000);
                            break;
                        case 'ammo':
                            if (player) player.ammo = Math.min(player.ammo + 5, config.player.maxAmmo);
                            break;
                        case 'token':
                            playerTokens += 1;
                            break;
                    }
                    items.splice(i, 1);
                    if (audioManager) audioManager.playSfx('pickup');
                }
            }
        }
        
        function spawnContinuousEnemies(dt) {
            if (gameManager.isWaveActive && !boss) {
                // Adjust spawn interval for increasing difficulty
                const spawnInterval = Math.max(0.5, 2 - gameManager.wave * 0.1);
                enemySpawnTimer -= dt;
                if (enemySpawnTimer <= 0) {
                    gameManager.spawnEnemiesForWave(gameManager.wave);
                    const spawnRate = config.enemies.spawnRatePerWave / (1 + gameManager.wave * 0.1);
                    enemySpawnTimer = spawnRate;
                }
            }
        }
        
        function checkAndSpawnShield(dt) {
            timeSinceLastShield += dt;
            if (timeSinceLastShield < config.shieldSpawn.cooldown) return;

            const currentChance = Math.min(
                player.shieldChanceBase + pityBonus,
                config.shieldSpawn.maxChanceCap
            );

            if (Math.random() * 100 < currentChance) {
                items.push(new Item(Math.random() * canvas.width, Math.random() * canvas.height, 'shield'));
                pityBonus = 0;
                timeSinceLastShield = 0;
            } else {
                pityBonus = Math.min(pityBonus + config.shieldSpawn.pityStep, config.shieldSpawn.pityMax);
            }
        }


        function endGame() {
            gameActive = false;
            isPaused = true;
            showPanel(gameOverMenu);
            const finalScoreElement = document.getElementById('final-score');
            const finalWaveElement = document.getElementById('final-wave');
            if(finalScoreElement) finalScoreElement.textContent = Math.round(gameManager.score);
            if(finalWaveElement) finalWaveElement.textContent = gameManager.wave;

            if (gameManager.score > highscore) {
                highscore = Math.round(gameManager.score);
                localStorage.setItem('shadow_escape_highscore', highscore);
                const hsEl = document.getElementById('highscore-display');
                if (hsEl) hsEl.textContent = highscore;
            }
            if (audioManager && audioManager.isInitialized) {
                audioManager.pauseAmbience();
            }
        }

        function hexToRgb(hex) {
            if (hex && hex.startsWith('hsl')) {
                const parts = hex.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (parts) {
                    let h = parseInt(parts[1], 10);
                    let s = parseInt(parts[2], 10) / 100;
                    let l = parseInt(parts[3], 10) / 100;

                    let c = (1 - Math.abs(2 * l - 1)) * s;
                    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
                    let m = l - c / 2;
                    let r = 0, g = 0, b = 0;

                    if (0 <= h && h < 60) {
                        r = c; g = x; b = 0;
                    } else if (60 <= h && h < 120) {
                        r = x; g = c; b = 0;
                    } else if (120 <= h && h < 180) {
                        r = 0; g = c; b = x;
                    } else if (180 <= h && h < 240) {
                        r = 0; g = x; b = c;
                    } else if (240 <= h && h < 300) {
                        r = x; g = 0; b = c;
                    } else if (300 <= h && h < 360) {
                        r = c; g = 0; b = x;
                    }
                    r = Math.round((r + m) * 255);
                    g = Math.round((g + m) * 255);
                    b = Math.round((b + m) * 255);
                    return { r, g, b };
                }
            }

            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function gameLoop(timestamp) {
            if (gameActive) {
                document.body.style.cursor = 'none';
            } else {
                document.body.style.cursor = 'default';
            }

            if (!gameActive) {
                lastTime = timestamp;
                requestAnimationFrame(gameLoop);
                return;
            }

            let dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (isSlowMotion) {
                dt *= 0.5;
                slowMotionTimer -= dt;
                if (slowMotionTimer <= 0) {
                    isSlowMotion = false;
                }
            }

            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            if (screenShakeTime > 0) {
                screenShakeTime -= dt;
                const shakeIntensity = 10 * (screenShakeTime / SCREEN_SHAKE_DURATION);
                screenShakeX = (Math.random() - 0.5) * shakeIntensity;
                screenShakeY = (Math.random() - 0.5) * shakeIntensity;
            } else {
                screenShakeX = 0;
                screenShakeY = 0;
            }
            if (mainContainer) mainContainer.style.transform = `translate(${screenShakeX}px, ${screenShakeY}px)`;

            if (player) {
                const inputVector = inputManager.getMovementVector();
                player.update(dt, inputVector);
                gameManager.score += dt * (1 + player.comboBonus) * scoreMultiplier;
            }
            
            gameManager.updateMissions('score');

            spawnContinuousEnemies(dt);
            checkAndSpawnShield(dt);

            enemies.forEach(enemy => {
                if (player) {
                    enemy.update(dt);
                }
            });
            items.forEach(item => item.update(dt));
            projectiles.forEach(p => p.update(dt));
            playerProjectiles.forEach(p => p.update(dt));
            obstacles.forEach(o => o.update(dt));

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(dt);
            }

            enemies = enemies.filter(enemy => {
                const isOffScreen = enemy.x < -config.enemies.spawnDistance * 2 || enemy.x > canvas.width + config.enemies.spawnDistance * 2 ||
                                   enemy.y < -config.enemies.spawnDistance * 2 || enemy.y > canvas.height + config.enemies.spawnDistance * 2;
                return !enemy.isDead && !isOffScreen; // Filter out dead enemies
            });
            items = items.filter(item => !item.isDead);
            particles = particles.filter(p => p.life > 0);
            projectiles = projectiles.filter(p => !p.isDead);
            playerProjectiles = playerProjectiles.filter(p => !p.isDead);
            
            if (player) {
                handleCollisions();
            }

            gameManager.updateHUD();

            if (gameManager.isWaveActive) {
                currentWaveDuration -= dt;
                if (waveTimerDisplay) waveTimerDisplay.textContent = Math.max(0, currentWaveDuration).toFixed(0);
                if (currentWaveDuration <= 0 && !boss) {
                    gameManager.isWaveActive = false;
                    waveTimer = config.waves.wavePauseDuration;
                    const tokensEarned = gameManager.tokensForWaveEnd();
                    playerTokens += tokensEarned;
                    localStorage.setItem('playerTokens', playerTokens);
                    showMessage(`پایان موج! شما ${tokensEarned} توکن کسب کردید.`);
                    gameManager.wave++;
                    gameManager.showUpgradeScreen();
                }
            } else {
                waveTimer -= dt;
                if (waveTimer <= 0) {
                    gameManager.showUpgradeScreen();
                }
            }
            
            gameManager.spawnItems();

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (player) {
                const waveHue = (gameManager.wave * 40) % 360;
                const dynamicColor = `hsl(${waveHue}, 80%, 70%)`;
                const bgGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, Math.max(canvas.width, canvas.height) * 0.7);

                const waveRgb = hexToRgb(dynamicColor);
                if (waveRgb) {
                    bgGradient.addColorStop(0, `rgba(${waveRgb.r}, ${waveRgb.g}, ${waveRgb.b}, 0.05)`);
                } else {
                    bgGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                }
                bgGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            obstacles.forEach(o => o.draw(ctx));

            particles.forEach(p => p.draw(ctx));
            items.forEach(item => item.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));
            playerProjectiles.forEach(p => p.draw(ctx));
            enemies.forEach(enemy => enemy.draw(ctx));
            if (player) {
                player.draw(ctx);
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        };

        document.addEventListener('DOMContentLoaded', () => {
            const hsEl = document.getElementById('highscore-display');
            if (hsEl) hsEl.textContent = highscore;

            resizeCanvas();

            inputManager.init();
            audioManager = new AudioManager();
            // Moved init() here to load audio before game starts
            audioManager.init();
            player = new Player(canvas.width / 2, canvas.height / 2);
            player.applyUpgrades();

            const $ = (id) => document.getElementById(id);

            const on = (id, type, handler) => {
                const el = $(id);
                if (el) el.addEventListener(type, handler);
            };

            const musicVolumeInput = $('music-volume');
            const sfxVolumeInput = $('sfx-volume');
            const mouseSensitivityInput = $('mouse-sensitivity');

            if (musicVolumeInput) musicVolumeInput.value = musicVolume;
            if (sfxVolumeInput) sfxVolumeInput.value = sfxVolume;
            if (mouseSensitivityInput) mouseSensitivityInput.value = mouseSensitivity;

            if (musicVolumeInput) {
                musicVolumeInput.addEventListener('input', (e) => {
                    musicVolume = parseFloat(e.target.value);
                    if (audioManager) audioManager.updateVolumes(musicVolume, sfxVolume);
                });
            }

            if (sfxVolumeInput) {
                sfxVolumeInput.addEventListener('input', (e) => {
                    sfxVolume = parseFloat(e.target.value);
                    if (audioManager) audioManager.updateVolumes(musicVolume, sfxVolume);
                });
            }

            if (mouseSensitivityInput) {
                mouseSensitivityInput.addEventListener('input', (e) => {
                    mouseSensitivity = parseFloat(e.target.value);
                    localStorage.setItem('mouseSensitivity', mouseSensitivity);
                });
            }

            on('play-button', 'click', () => {
                startGame();
            });

            on('shop-button', 'click', () => {
                gameManager.showShopScreen();
            });

            on('tutorial-button', 'click', () => {
                showPanel(tutorialMenu);
            });

            on('settings-button', 'click', () => {
                showPanel(settingsMenu);
            });

            on('back-to-main', 'click', () => {
                showPanel(mainMenu);
            });
            
            on('back-from-missions', 'click', () => {
                gameManager.showUpgradeScreen();
            });
            
            on('close-shop-button', 'click', () => {
                showPanel(mainMenu);
            });

            on('back-to-main-from-settings', 'click', () => {
                showPanel(mainMenu);
            });
            
            on('show-missions-button', 'click', () => {
                gameManager.showMissionsScreen();
            });

            on('retry-button', 'click', () => {
                startGame();
            });

            on('back-to-main-from-gameover', 'click', () => {
                showPanel(mainMenu);
            });
            
            // Removed magical-upgrade-button functionality and event listener
            
            // Removed read-tutorial-button functionality and event listener

            if (audioToggle) {
                audioToggle.addEventListener('click', () => {
                    if (audioManager) audioManager.toggleMute();
                });
            }

            // No event listener needed for message-box as it auto-hides now.
            
            if (shootBtn) {
                shootBtn.addEventListener('click', () => {
                    if (gameActive && player && player.ammo > 0) {
                        player.shoot();
                    } else if (gameActive && player && player.ammo <= 0) {
                        showMessage('گلوله‌ای ندارید. لطفاً از فروشگاه گلوله بخرید!');
                    }
                });
            }

            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
